// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/bengobox/treasury-api/internal/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/bengobox/treasury-api/internal/ent/chartofaccount"
	"github.com/bengobox/treasury-api/internal/ent/invoice"
	"github.com/bengobox/treasury-api/internal/ent/ledgertransaction"
	"github.com/bengobox/treasury-api/internal/ent/outboxevent"
	"github.com/bengobox/treasury-api/internal/ent/paymentintent"
	"github.com/bengobox/treasury-api/internal/ent/paymenttransaction"
	"github.com/bengobox/treasury-api/internal/ent/rolepermission"
	"github.com/bengobox/treasury-api/internal/ent/treasurypermission"
	"github.com/bengobox/treasury-api/internal/ent/treasuryrole"
	"github.com/bengobox/treasury-api/internal/ent/treasuryuser"
	"github.com/bengobox/treasury-api/internal/ent/userroleassignment"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ChartOfAccount is the client for interacting with the ChartOfAccount builders.
	ChartOfAccount *ChartOfAccountClient
	// Invoice is the client for interacting with the Invoice builders.
	Invoice *InvoiceClient
	// LedgerTransaction is the client for interacting with the LedgerTransaction builders.
	LedgerTransaction *LedgerTransactionClient
	// OutboxEvent is the client for interacting with the OutboxEvent builders.
	OutboxEvent *OutboxEventClient
	// PaymentIntent is the client for interacting with the PaymentIntent builders.
	PaymentIntent *PaymentIntentClient
	// PaymentTransaction is the client for interacting with the PaymentTransaction builders.
	PaymentTransaction *PaymentTransactionClient
	// RolePermission is the client for interacting with the RolePermission builders.
	RolePermission *RolePermissionClient
	// TreasuryPermission is the client for interacting with the TreasuryPermission builders.
	TreasuryPermission *TreasuryPermissionClient
	// TreasuryRole is the client for interacting with the TreasuryRole builders.
	TreasuryRole *TreasuryRoleClient
	// TreasuryUser is the client for interacting with the TreasuryUser builders.
	TreasuryUser *TreasuryUserClient
	// UserRoleAssignment is the client for interacting with the UserRoleAssignment builders.
	UserRoleAssignment *UserRoleAssignmentClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ChartOfAccount = NewChartOfAccountClient(c.config)
	c.Invoice = NewInvoiceClient(c.config)
	c.LedgerTransaction = NewLedgerTransactionClient(c.config)
	c.OutboxEvent = NewOutboxEventClient(c.config)
	c.PaymentIntent = NewPaymentIntentClient(c.config)
	c.PaymentTransaction = NewPaymentTransactionClient(c.config)
	c.RolePermission = NewRolePermissionClient(c.config)
	c.TreasuryPermission = NewTreasuryPermissionClient(c.config)
	c.TreasuryRole = NewTreasuryRoleClient(c.config)
	c.TreasuryUser = NewTreasuryUserClient(c.config)
	c.UserRoleAssignment = NewUserRoleAssignmentClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		ChartOfAccount:     NewChartOfAccountClient(cfg),
		Invoice:            NewInvoiceClient(cfg),
		LedgerTransaction:  NewLedgerTransactionClient(cfg),
		OutboxEvent:        NewOutboxEventClient(cfg),
		PaymentIntent:      NewPaymentIntentClient(cfg),
		PaymentTransaction: NewPaymentTransactionClient(cfg),
		RolePermission:     NewRolePermissionClient(cfg),
		TreasuryPermission: NewTreasuryPermissionClient(cfg),
		TreasuryRole:       NewTreasuryRoleClient(cfg),
		TreasuryUser:       NewTreasuryUserClient(cfg),
		UserRoleAssignment: NewUserRoleAssignmentClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		ChartOfAccount:     NewChartOfAccountClient(cfg),
		Invoice:            NewInvoiceClient(cfg),
		LedgerTransaction:  NewLedgerTransactionClient(cfg),
		OutboxEvent:        NewOutboxEventClient(cfg),
		PaymentIntent:      NewPaymentIntentClient(cfg),
		PaymentTransaction: NewPaymentTransactionClient(cfg),
		RolePermission:     NewRolePermissionClient(cfg),
		TreasuryPermission: NewTreasuryPermissionClient(cfg),
		TreasuryRole:       NewTreasuryRoleClient(cfg),
		TreasuryUser:       NewTreasuryUserClient(cfg),
		UserRoleAssignment: NewUserRoleAssignmentClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ChartOfAccount.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ChartOfAccount, c.Invoice, c.LedgerTransaction, c.OutboxEvent,
		c.PaymentIntent, c.PaymentTransaction, c.RolePermission, c.TreasuryPermission,
		c.TreasuryRole, c.TreasuryUser, c.UserRoleAssignment,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ChartOfAccount, c.Invoice, c.LedgerTransaction, c.OutboxEvent,
		c.PaymentIntent, c.PaymentTransaction, c.RolePermission, c.TreasuryPermission,
		c.TreasuryRole, c.TreasuryUser, c.UserRoleAssignment,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ChartOfAccountMutation:
		return c.ChartOfAccount.mutate(ctx, m)
	case *InvoiceMutation:
		return c.Invoice.mutate(ctx, m)
	case *LedgerTransactionMutation:
		return c.LedgerTransaction.mutate(ctx, m)
	case *OutboxEventMutation:
		return c.OutboxEvent.mutate(ctx, m)
	case *PaymentIntentMutation:
		return c.PaymentIntent.mutate(ctx, m)
	case *PaymentTransactionMutation:
		return c.PaymentTransaction.mutate(ctx, m)
	case *RolePermissionMutation:
		return c.RolePermission.mutate(ctx, m)
	case *TreasuryPermissionMutation:
		return c.TreasuryPermission.mutate(ctx, m)
	case *TreasuryRoleMutation:
		return c.TreasuryRole.mutate(ctx, m)
	case *TreasuryUserMutation:
		return c.TreasuryUser.mutate(ctx, m)
	case *UserRoleAssignmentMutation:
		return c.UserRoleAssignment.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ChartOfAccountClient is a client for the ChartOfAccount schema.
type ChartOfAccountClient struct {
	config
}

// NewChartOfAccountClient returns a client for the ChartOfAccount from the given config.
func NewChartOfAccountClient(c config) *ChartOfAccountClient {
	return &ChartOfAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chartofaccount.Hooks(f(g(h())))`.
func (c *ChartOfAccountClient) Use(hooks ...Hook) {
	c.hooks.ChartOfAccount = append(c.hooks.ChartOfAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chartofaccount.Intercept(f(g(h())))`.
func (c *ChartOfAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.ChartOfAccount = append(c.inters.ChartOfAccount, interceptors...)
}

// Create returns a builder for creating a ChartOfAccount entity.
func (c *ChartOfAccountClient) Create() *ChartOfAccountCreate {
	mutation := newChartOfAccountMutation(c.config, OpCreate)
	return &ChartOfAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ChartOfAccount entities.
func (c *ChartOfAccountClient) CreateBulk(builders ...*ChartOfAccountCreate) *ChartOfAccountCreateBulk {
	return &ChartOfAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChartOfAccountClient) MapCreateBulk(slice any, setFunc func(*ChartOfAccountCreate, int)) *ChartOfAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChartOfAccountCreateBulk{err: fmt.Errorf("calling to ChartOfAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChartOfAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChartOfAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ChartOfAccount.
func (c *ChartOfAccountClient) Update() *ChartOfAccountUpdate {
	mutation := newChartOfAccountMutation(c.config, OpUpdate)
	return &ChartOfAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChartOfAccountClient) UpdateOne(_m *ChartOfAccount) *ChartOfAccountUpdateOne {
	mutation := newChartOfAccountMutation(c.config, OpUpdateOne, withChartOfAccount(_m))
	return &ChartOfAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChartOfAccountClient) UpdateOneID(id uuid.UUID) *ChartOfAccountUpdateOne {
	mutation := newChartOfAccountMutation(c.config, OpUpdateOne, withChartOfAccountID(id))
	return &ChartOfAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ChartOfAccount.
func (c *ChartOfAccountClient) Delete() *ChartOfAccountDelete {
	mutation := newChartOfAccountMutation(c.config, OpDelete)
	return &ChartOfAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChartOfAccountClient) DeleteOne(_m *ChartOfAccount) *ChartOfAccountDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChartOfAccountClient) DeleteOneID(id uuid.UUID) *ChartOfAccountDeleteOne {
	builder := c.Delete().Where(chartofaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChartOfAccountDeleteOne{builder}
}

// Query returns a query builder for ChartOfAccount.
func (c *ChartOfAccountClient) Query() *ChartOfAccountQuery {
	return &ChartOfAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChartOfAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a ChartOfAccount entity by its id.
func (c *ChartOfAccountClient) Get(ctx context.Context, id uuid.UUID) (*ChartOfAccount, error) {
	return c.Query().Where(chartofaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChartOfAccountClient) GetX(ctx context.Context, id uuid.UUID) *ChartOfAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a ChartOfAccount.
func (c *ChartOfAccountClient) QueryParent(_m *ChartOfAccount) *ChartOfAccountQuery {
	query := (&ChartOfAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chartofaccount.Table, chartofaccount.FieldID, id),
			sqlgraph.To(chartofaccount.Table, chartofaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, chartofaccount.ParentTable, chartofaccount.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a ChartOfAccount.
func (c *ChartOfAccountClient) QueryChildren(_m *ChartOfAccount) *ChartOfAccountQuery {
	query := (&ChartOfAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chartofaccount.Table, chartofaccount.FieldID, id),
			sqlgraph.To(chartofaccount.Table, chartofaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, chartofaccount.ChildrenTable, chartofaccount.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChartOfAccountClient) Hooks() []Hook {
	return c.hooks.ChartOfAccount
}

// Interceptors returns the client interceptors.
func (c *ChartOfAccountClient) Interceptors() []Interceptor {
	return c.inters.ChartOfAccount
}

func (c *ChartOfAccountClient) mutate(ctx context.Context, m *ChartOfAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChartOfAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChartOfAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChartOfAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChartOfAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ChartOfAccount mutation op: %q", m.Op())
	}
}

// InvoiceClient is a client for the Invoice schema.
type InvoiceClient struct {
	config
}

// NewInvoiceClient returns a client for the Invoice from the given config.
func NewInvoiceClient(c config) *InvoiceClient {
	return &InvoiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invoice.Hooks(f(g(h())))`.
func (c *InvoiceClient) Use(hooks ...Hook) {
	c.hooks.Invoice = append(c.hooks.Invoice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invoice.Intercept(f(g(h())))`.
func (c *InvoiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invoice = append(c.inters.Invoice, interceptors...)
}

// Create returns a builder for creating a Invoice entity.
func (c *InvoiceClient) Create() *InvoiceCreate {
	mutation := newInvoiceMutation(c.config, OpCreate)
	return &InvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invoice entities.
func (c *InvoiceClient) CreateBulk(builders ...*InvoiceCreate) *InvoiceCreateBulk {
	return &InvoiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvoiceClient) MapCreateBulk(slice any, setFunc func(*InvoiceCreate, int)) *InvoiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvoiceCreateBulk{err: fmt.Errorf("calling to InvoiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvoiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvoiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invoice.
func (c *InvoiceClient) Update() *InvoiceUpdate {
	mutation := newInvoiceMutation(c.config, OpUpdate)
	return &InvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvoiceClient) UpdateOne(_m *Invoice) *InvoiceUpdateOne {
	mutation := newInvoiceMutation(c.config, OpUpdateOne, withInvoice(_m))
	return &InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvoiceClient) UpdateOneID(id uuid.UUID) *InvoiceUpdateOne {
	mutation := newInvoiceMutation(c.config, OpUpdateOne, withInvoiceID(id))
	return &InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invoice.
func (c *InvoiceClient) Delete() *InvoiceDelete {
	mutation := newInvoiceMutation(c.config, OpDelete)
	return &InvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvoiceClient) DeleteOne(_m *Invoice) *InvoiceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvoiceClient) DeleteOneID(id uuid.UUID) *InvoiceDeleteOne {
	builder := c.Delete().Where(invoice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvoiceDeleteOne{builder}
}

// Query returns a query builder for Invoice.
func (c *InvoiceClient) Query() *InvoiceQuery {
	return &InvoiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvoice},
		inters: c.Interceptors(),
	}
}

// Get returns a Invoice entity by its id.
func (c *InvoiceClient) Get(ctx context.Context, id uuid.UUID) (*Invoice, error) {
	return c.Query().Where(invoice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvoiceClient) GetX(ctx context.Context, id uuid.UUID) *Invoice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InvoiceClient) Hooks() []Hook {
	return c.hooks.Invoice
}

// Interceptors returns the client interceptors.
func (c *InvoiceClient) Interceptors() []Interceptor {
	return c.inters.Invoice
}

func (c *InvoiceClient) mutate(ctx context.Context, m *InvoiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Invoice mutation op: %q", m.Op())
	}
}

// LedgerTransactionClient is a client for the LedgerTransaction schema.
type LedgerTransactionClient struct {
	config
}

// NewLedgerTransactionClient returns a client for the LedgerTransaction from the given config.
func NewLedgerTransactionClient(c config) *LedgerTransactionClient {
	return &LedgerTransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ledgertransaction.Hooks(f(g(h())))`.
func (c *LedgerTransactionClient) Use(hooks ...Hook) {
	c.hooks.LedgerTransaction = append(c.hooks.LedgerTransaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ledgertransaction.Intercept(f(g(h())))`.
func (c *LedgerTransactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.LedgerTransaction = append(c.inters.LedgerTransaction, interceptors...)
}

// Create returns a builder for creating a LedgerTransaction entity.
func (c *LedgerTransactionClient) Create() *LedgerTransactionCreate {
	mutation := newLedgerTransactionMutation(c.config, OpCreate)
	return &LedgerTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LedgerTransaction entities.
func (c *LedgerTransactionClient) CreateBulk(builders ...*LedgerTransactionCreate) *LedgerTransactionCreateBulk {
	return &LedgerTransactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LedgerTransactionClient) MapCreateBulk(slice any, setFunc func(*LedgerTransactionCreate, int)) *LedgerTransactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LedgerTransactionCreateBulk{err: fmt.Errorf("calling to LedgerTransactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LedgerTransactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LedgerTransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LedgerTransaction.
func (c *LedgerTransactionClient) Update() *LedgerTransactionUpdate {
	mutation := newLedgerTransactionMutation(c.config, OpUpdate)
	return &LedgerTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LedgerTransactionClient) UpdateOne(_m *LedgerTransaction) *LedgerTransactionUpdateOne {
	mutation := newLedgerTransactionMutation(c.config, OpUpdateOne, withLedgerTransaction(_m))
	return &LedgerTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LedgerTransactionClient) UpdateOneID(id uuid.UUID) *LedgerTransactionUpdateOne {
	mutation := newLedgerTransactionMutation(c.config, OpUpdateOne, withLedgerTransactionID(id))
	return &LedgerTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LedgerTransaction.
func (c *LedgerTransactionClient) Delete() *LedgerTransactionDelete {
	mutation := newLedgerTransactionMutation(c.config, OpDelete)
	return &LedgerTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LedgerTransactionClient) DeleteOne(_m *LedgerTransaction) *LedgerTransactionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LedgerTransactionClient) DeleteOneID(id uuid.UUID) *LedgerTransactionDeleteOne {
	builder := c.Delete().Where(ledgertransaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LedgerTransactionDeleteOne{builder}
}

// Query returns a query builder for LedgerTransaction.
func (c *LedgerTransactionClient) Query() *LedgerTransactionQuery {
	return &LedgerTransactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLedgerTransaction},
		inters: c.Interceptors(),
	}
}

// Get returns a LedgerTransaction entity by its id.
func (c *LedgerTransactionClient) Get(ctx context.Context, id uuid.UUID) (*LedgerTransaction, error) {
	return c.Query().Where(ledgertransaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LedgerTransactionClient) GetX(ctx context.Context, id uuid.UUID) *LedgerTransaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a LedgerTransaction.
func (c *LedgerTransactionClient) QueryAccount(_m *LedgerTransaction) *ChartOfAccountQuery {
	query := (&ChartOfAccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ledgertransaction.Table, ledgertransaction.FieldID, id),
			sqlgraph.To(chartofaccount.Table, chartofaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, ledgertransaction.AccountTable, ledgertransaction.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LedgerTransactionClient) Hooks() []Hook {
	return c.hooks.LedgerTransaction
}

// Interceptors returns the client interceptors.
func (c *LedgerTransactionClient) Interceptors() []Interceptor {
	return c.inters.LedgerTransaction
}

func (c *LedgerTransactionClient) mutate(ctx context.Context, m *LedgerTransactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LedgerTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LedgerTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LedgerTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LedgerTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LedgerTransaction mutation op: %q", m.Op())
	}
}

// OutboxEventClient is a client for the OutboxEvent schema.
type OutboxEventClient struct {
	config
}

// NewOutboxEventClient returns a client for the OutboxEvent from the given config.
func NewOutboxEventClient(c config) *OutboxEventClient {
	return &OutboxEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `outboxevent.Hooks(f(g(h())))`.
func (c *OutboxEventClient) Use(hooks ...Hook) {
	c.hooks.OutboxEvent = append(c.hooks.OutboxEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `outboxevent.Intercept(f(g(h())))`.
func (c *OutboxEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.OutboxEvent = append(c.inters.OutboxEvent, interceptors...)
}

// Create returns a builder for creating a OutboxEvent entity.
func (c *OutboxEventClient) Create() *OutboxEventCreate {
	mutation := newOutboxEventMutation(c.config, OpCreate)
	return &OutboxEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OutboxEvent entities.
func (c *OutboxEventClient) CreateBulk(builders ...*OutboxEventCreate) *OutboxEventCreateBulk {
	return &OutboxEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OutboxEventClient) MapCreateBulk(slice any, setFunc func(*OutboxEventCreate, int)) *OutboxEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OutboxEventCreateBulk{err: fmt.Errorf("calling to OutboxEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OutboxEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OutboxEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OutboxEvent.
func (c *OutboxEventClient) Update() *OutboxEventUpdate {
	mutation := newOutboxEventMutation(c.config, OpUpdate)
	return &OutboxEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OutboxEventClient) UpdateOne(_m *OutboxEvent) *OutboxEventUpdateOne {
	mutation := newOutboxEventMutation(c.config, OpUpdateOne, withOutboxEvent(_m))
	return &OutboxEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OutboxEventClient) UpdateOneID(id uuid.UUID) *OutboxEventUpdateOne {
	mutation := newOutboxEventMutation(c.config, OpUpdateOne, withOutboxEventID(id))
	return &OutboxEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OutboxEvent.
func (c *OutboxEventClient) Delete() *OutboxEventDelete {
	mutation := newOutboxEventMutation(c.config, OpDelete)
	return &OutboxEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OutboxEventClient) DeleteOne(_m *OutboxEvent) *OutboxEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OutboxEventClient) DeleteOneID(id uuid.UUID) *OutboxEventDeleteOne {
	builder := c.Delete().Where(outboxevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OutboxEventDeleteOne{builder}
}

// Query returns a query builder for OutboxEvent.
func (c *OutboxEventClient) Query() *OutboxEventQuery {
	return &OutboxEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOutboxEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a OutboxEvent entity by its id.
func (c *OutboxEventClient) Get(ctx context.Context, id uuid.UUID) (*OutboxEvent, error) {
	return c.Query().Where(outboxevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OutboxEventClient) GetX(ctx context.Context, id uuid.UUID) *OutboxEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OutboxEventClient) Hooks() []Hook {
	return c.hooks.OutboxEvent
}

// Interceptors returns the client interceptors.
func (c *OutboxEventClient) Interceptors() []Interceptor {
	return c.inters.OutboxEvent
}

func (c *OutboxEventClient) mutate(ctx context.Context, m *OutboxEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OutboxEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OutboxEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OutboxEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OutboxEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OutboxEvent mutation op: %q", m.Op())
	}
}

// PaymentIntentClient is a client for the PaymentIntent schema.
type PaymentIntentClient struct {
	config
}

// NewPaymentIntentClient returns a client for the PaymentIntent from the given config.
func NewPaymentIntentClient(c config) *PaymentIntentClient {
	return &PaymentIntentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `paymentintent.Hooks(f(g(h())))`.
func (c *PaymentIntentClient) Use(hooks ...Hook) {
	c.hooks.PaymentIntent = append(c.hooks.PaymentIntent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `paymentintent.Intercept(f(g(h())))`.
func (c *PaymentIntentClient) Intercept(interceptors ...Interceptor) {
	c.inters.PaymentIntent = append(c.inters.PaymentIntent, interceptors...)
}

// Create returns a builder for creating a PaymentIntent entity.
func (c *PaymentIntentClient) Create() *PaymentIntentCreate {
	mutation := newPaymentIntentMutation(c.config, OpCreate)
	return &PaymentIntentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PaymentIntent entities.
func (c *PaymentIntentClient) CreateBulk(builders ...*PaymentIntentCreate) *PaymentIntentCreateBulk {
	return &PaymentIntentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentIntentClient) MapCreateBulk(slice any, setFunc func(*PaymentIntentCreate, int)) *PaymentIntentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentIntentCreateBulk{err: fmt.Errorf("calling to PaymentIntentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentIntentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentIntentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PaymentIntent.
func (c *PaymentIntentClient) Update() *PaymentIntentUpdate {
	mutation := newPaymentIntentMutation(c.config, OpUpdate)
	return &PaymentIntentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentIntentClient) UpdateOne(_m *PaymentIntent) *PaymentIntentUpdateOne {
	mutation := newPaymentIntentMutation(c.config, OpUpdateOne, withPaymentIntent(_m))
	return &PaymentIntentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentIntentClient) UpdateOneID(id uuid.UUID) *PaymentIntentUpdateOne {
	mutation := newPaymentIntentMutation(c.config, OpUpdateOne, withPaymentIntentID(id))
	return &PaymentIntentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PaymentIntent.
func (c *PaymentIntentClient) Delete() *PaymentIntentDelete {
	mutation := newPaymentIntentMutation(c.config, OpDelete)
	return &PaymentIntentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentIntentClient) DeleteOne(_m *PaymentIntent) *PaymentIntentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentIntentClient) DeleteOneID(id uuid.UUID) *PaymentIntentDeleteOne {
	builder := c.Delete().Where(paymentintent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentIntentDeleteOne{builder}
}

// Query returns a query builder for PaymentIntent.
func (c *PaymentIntentClient) Query() *PaymentIntentQuery {
	return &PaymentIntentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePaymentIntent},
		inters: c.Interceptors(),
	}
}

// Get returns a PaymentIntent entity by its id.
func (c *PaymentIntentClient) Get(ctx context.Context, id uuid.UUID) (*PaymentIntent, error) {
	return c.Query().Where(paymentintent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentIntentClient) GetX(ctx context.Context, id uuid.UUID) *PaymentIntent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PaymentIntentClient) Hooks() []Hook {
	return c.hooks.PaymentIntent
}

// Interceptors returns the client interceptors.
func (c *PaymentIntentClient) Interceptors() []Interceptor {
	return c.inters.PaymentIntent
}

func (c *PaymentIntentClient) mutate(ctx context.Context, m *PaymentIntentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentIntentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentIntentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentIntentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentIntentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PaymentIntent mutation op: %q", m.Op())
	}
}

// PaymentTransactionClient is a client for the PaymentTransaction schema.
type PaymentTransactionClient struct {
	config
}

// NewPaymentTransactionClient returns a client for the PaymentTransaction from the given config.
func NewPaymentTransactionClient(c config) *PaymentTransactionClient {
	return &PaymentTransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `paymenttransaction.Hooks(f(g(h())))`.
func (c *PaymentTransactionClient) Use(hooks ...Hook) {
	c.hooks.PaymentTransaction = append(c.hooks.PaymentTransaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `paymenttransaction.Intercept(f(g(h())))`.
func (c *PaymentTransactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PaymentTransaction = append(c.inters.PaymentTransaction, interceptors...)
}

// Create returns a builder for creating a PaymentTransaction entity.
func (c *PaymentTransactionClient) Create() *PaymentTransactionCreate {
	mutation := newPaymentTransactionMutation(c.config, OpCreate)
	return &PaymentTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PaymentTransaction entities.
func (c *PaymentTransactionClient) CreateBulk(builders ...*PaymentTransactionCreate) *PaymentTransactionCreateBulk {
	return &PaymentTransactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentTransactionClient) MapCreateBulk(slice any, setFunc func(*PaymentTransactionCreate, int)) *PaymentTransactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentTransactionCreateBulk{err: fmt.Errorf("calling to PaymentTransactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentTransactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentTransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PaymentTransaction.
func (c *PaymentTransactionClient) Update() *PaymentTransactionUpdate {
	mutation := newPaymentTransactionMutation(c.config, OpUpdate)
	return &PaymentTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentTransactionClient) UpdateOne(_m *PaymentTransaction) *PaymentTransactionUpdateOne {
	mutation := newPaymentTransactionMutation(c.config, OpUpdateOne, withPaymentTransaction(_m))
	return &PaymentTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentTransactionClient) UpdateOneID(id uuid.UUID) *PaymentTransactionUpdateOne {
	mutation := newPaymentTransactionMutation(c.config, OpUpdateOne, withPaymentTransactionID(id))
	return &PaymentTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PaymentTransaction.
func (c *PaymentTransactionClient) Delete() *PaymentTransactionDelete {
	mutation := newPaymentTransactionMutation(c.config, OpDelete)
	return &PaymentTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentTransactionClient) DeleteOne(_m *PaymentTransaction) *PaymentTransactionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentTransactionClient) DeleteOneID(id uuid.UUID) *PaymentTransactionDeleteOne {
	builder := c.Delete().Where(paymenttransaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentTransactionDeleteOne{builder}
}

// Query returns a query builder for PaymentTransaction.
func (c *PaymentTransactionClient) Query() *PaymentTransactionQuery {
	return &PaymentTransactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePaymentTransaction},
		inters: c.Interceptors(),
	}
}

// Get returns a PaymentTransaction entity by its id.
func (c *PaymentTransactionClient) Get(ctx context.Context, id uuid.UUID) (*PaymentTransaction, error) {
	return c.Query().Where(paymenttransaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentTransactionClient) GetX(ctx context.Context, id uuid.UUID) *PaymentTransaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PaymentTransactionClient) Hooks() []Hook {
	return c.hooks.PaymentTransaction
}

// Interceptors returns the client interceptors.
func (c *PaymentTransactionClient) Interceptors() []Interceptor {
	return c.inters.PaymentTransaction
}

func (c *PaymentTransactionClient) mutate(ctx context.Context, m *PaymentTransactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PaymentTransaction mutation op: %q", m.Op())
	}
}

// RolePermissionClient is a client for the RolePermission schema.
type RolePermissionClient struct {
	config
}

// NewRolePermissionClient returns a client for the RolePermission from the given config.
func NewRolePermissionClient(c config) *RolePermissionClient {
	return &RolePermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rolepermission.Hooks(f(g(h())))`.
func (c *RolePermissionClient) Use(hooks ...Hook) {
	c.hooks.RolePermission = append(c.hooks.RolePermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rolepermission.Intercept(f(g(h())))`.
func (c *RolePermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.RolePermission = append(c.inters.RolePermission, interceptors...)
}

// Create returns a builder for creating a RolePermission entity.
func (c *RolePermissionClient) Create() *RolePermissionCreate {
	mutation := newRolePermissionMutation(c.config, OpCreate)
	return &RolePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RolePermission entities.
func (c *RolePermissionClient) CreateBulk(builders ...*RolePermissionCreate) *RolePermissionCreateBulk {
	return &RolePermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RolePermissionClient) MapCreateBulk(slice any, setFunc func(*RolePermissionCreate, int)) *RolePermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RolePermissionCreateBulk{err: fmt.Errorf("calling to RolePermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RolePermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RolePermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RolePermission.
func (c *RolePermissionClient) Update() *RolePermissionUpdate {
	mutation := newRolePermissionMutation(c.config, OpUpdate)
	return &RolePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RolePermissionClient) UpdateOne(_m *RolePermission) *RolePermissionUpdateOne {
	mutation := newRolePermissionMutation(c.config, OpUpdateOne, withRolePermission(_m))
	return &RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RolePermissionClient) UpdateOneID(id int) *RolePermissionUpdateOne {
	mutation := newRolePermissionMutation(c.config, OpUpdateOne, withRolePermissionID(id))
	return &RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RolePermission.
func (c *RolePermissionClient) Delete() *RolePermissionDelete {
	mutation := newRolePermissionMutation(c.config, OpDelete)
	return &RolePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RolePermissionClient) DeleteOne(_m *RolePermission) *RolePermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RolePermissionClient) DeleteOneID(id int) *RolePermissionDeleteOne {
	builder := c.Delete().Where(rolepermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RolePermissionDeleteOne{builder}
}

// Query returns a query builder for RolePermission.
func (c *RolePermissionClient) Query() *RolePermissionQuery {
	return &RolePermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRolePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a RolePermission entity by its id.
func (c *RolePermissionClient) Get(ctx context.Context, id int) (*RolePermission, error) {
	return c.Query().Where(rolepermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RolePermissionClient) GetX(ctx context.Context, id int) *RolePermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRole queries the role edge of a RolePermission.
func (c *RolePermissionClient) QueryRole(_m *RolePermission) *TreasuryRoleQuery {
	query := (&TreasuryRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolepermission.Table, rolepermission.FieldID, id),
			sqlgraph.To(treasuryrole.Table, treasuryrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, rolepermission.RoleTable, rolepermission.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermission queries the permission edge of a RolePermission.
func (c *RolePermissionClient) QueryPermission(_m *RolePermission) *TreasuryPermissionQuery {
	query := (&TreasuryPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolepermission.Table, rolepermission.FieldID, id),
			sqlgraph.To(treasurypermission.Table, treasurypermission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, rolepermission.PermissionTable, rolepermission.PermissionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RolePermissionClient) Hooks() []Hook {
	return c.hooks.RolePermission
}

// Interceptors returns the client interceptors.
func (c *RolePermissionClient) Interceptors() []Interceptor {
	return c.inters.RolePermission
}

func (c *RolePermissionClient) mutate(ctx context.Context, m *RolePermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RolePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RolePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RolePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RolePermission mutation op: %q", m.Op())
	}
}

// TreasuryPermissionClient is a client for the TreasuryPermission schema.
type TreasuryPermissionClient struct {
	config
}

// NewTreasuryPermissionClient returns a client for the TreasuryPermission from the given config.
func NewTreasuryPermissionClient(c config) *TreasuryPermissionClient {
	return &TreasuryPermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `treasurypermission.Hooks(f(g(h())))`.
func (c *TreasuryPermissionClient) Use(hooks ...Hook) {
	c.hooks.TreasuryPermission = append(c.hooks.TreasuryPermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `treasurypermission.Intercept(f(g(h())))`.
func (c *TreasuryPermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TreasuryPermission = append(c.inters.TreasuryPermission, interceptors...)
}

// Create returns a builder for creating a TreasuryPermission entity.
func (c *TreasuryPermissionClient) Create() *TreasuryPermissionCreate {
	mutation := newTreasuryPermissionMutation(c.config, OpCreate)
	return &TreasuryPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TreasuryPermission entities.
func (c *TreasuryPermissionClient) CreateBulk(builders ...*TreasuryPermissionCreate) *TreasuryPermissionCreateBulk {
	return &TreasuryPermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TreasuryPermissionClient) MapCreateBulk(slice any, setFunc func(*TreasuryPermissionCreate, int)) *TreasuryPermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TreasuryPermissionCreateBulk{err: fmt.Errorf("calling to TreasuryPermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TreasuryPermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TreasuryPermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TreasuryPermission.
func (c *TreasuryPermissionClient) Update() *TreasuryPermissionUpdate {
	mutation := newTreasuryPermissionMutation(c.config, OpUpdate)
	return &TreasuryPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TreasuryPermissionClient) UpdateOne(_m *TreasuryPermission) *TreasuryPermissionUpdateOne {
	mutation := newTreasuryPermissionMutation(c.config, OpUpdateOne, withTreasuryPermission(_m))
	return &TreasuryPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TreasuryPermissionClient) UpdateOneID(id uuid.UUID) *TreasuryPermissionUpdateOne {
	mutation := newTreasuryPermissionMutation(c.config, OpUpdateOne, withTreasuryPermissionID(id))
	return &TreasuryPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TreasuryPermission.
func (c *TreasuryPermissionClient) Delete() *TreasuryPermissionDelete {
	mutation := newTreasuryPermissionMutation(c.config, OpDelete)
	return &TreasuryPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TreasuryPermissionClient) DeleteOne(_m *TreasuryPermission) *TreasuryPermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TreasuryPermissionClient) DeleteOneID(id uuid.UUID) *TreasuryPermissionDeleteOne {
	builder := c.Delete().Where(treasurypermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TreasuryPermissionDeleteOne{builder}
}

// Query returns a query builder for TreasuryPermission.
func (c *TreasuryPermissionClient) Query() *TreasuryPermissionQuery {
	return &TreasuryPermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTreasuryPermission},
		inters: c.Interceptors(),
	}
}

// Get returns a TreasuryPermission entity by its id.
func (c *TreasuryPermissionClient) Get(ctx context.Context, id uuid.UUID) (*TreasuryPermission, error) {
	return c.Query().Where(treasurypermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TreasuryPermissionClient) GetX(ctx context.Context, id uuid.UUID) *TreasuryPermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a TreasuryPermission.
func (c *TreasuryPermissionClient) QueryRoles(_m *TreasuryPermission) *TreasuryRoleQuery {
	query := (&TreasuryRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(treasurypermission.Table, treasurypermission.FieldID, id),
			sqlgraph.To(treasuryrole.Table, treasuryrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, treasurypermission.RolesTable, treasurypermission.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRolePermissions queries the role_permissions edge of a TreasuryPermission.
func (c *TreasuryPermissionClient) QueryRolePermissions(_m *TreasuryPermission) *RolePermissionQuery {
	query := (&RolePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(treasurypermission.Table, treasurypermission.FieldID, id),
			sqlgraph.To(rolepermission.Table, rolepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, treasurypermission.RolePermissionsTable, treasurypermission.RolePermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TreasuryPermissionClient) Hooks() []Hook {
	return c.hooks.TreasuryPermission
}

// Interceptors returns the client interceptors.
func (c *TreasuryPermissionClient) Interceptors() []Interceptor {
	return c.inters.TreasuryPermission
}

func (c *TreasuryPermissionClient) mutate(ctx context.Context, m *TreasuryPermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TreasuryPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TreasuryPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TreasuryPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TreasuryPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TreasuryPermission mutation op: %q", m.Op())
	}
}

// TreasuryRoleClient is a client for the TreasuryRole schema.
type TreasuryRoleClient struct {
	config
}

// NewTreasuryRoleClient returns a client for the TreasuryRole from the given config.
func NewTreasuryRoleClient(c config) *TreasuryRoleClient {
	return &TreasuryRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `treasuryrole.Hooks(f(g(h())))`.
func (c *TreasuryRoleClient) Use(hooks ...Hook) {
	c.hooks.TreasuryRole = append(c.hooks.TreasuryRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `treasuryrole.Intercept(f(g(h())))`.
func (c *TreasuryRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.TreasuryRole = append(c.inters.TreasuryRole, interceptors...)
}

// Create returns a builder for creating a TreasuryRole entity.
func (c *TreasuryRoleClient) Create() *TreasuryRoleCreate {
	mutation := newTreasuryRoleMutation(c.config, OpCreate)
	return &TreasuryRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TreasuryRole entities.
func (c *TreasuryRoleClient) CreateBulk(builders ...*TreasuryRoleCreate) *TreasuryRoleCreateBulk {
	return &TreasuryRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TreasuryRoleClient) MapCreateBulk(slice any, setFunc func(*TreasuryRoleCreate, int)) *TreasuryRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TreasuryRoleCreateBulk{err: fmt.Errorf("calling to TreasuryRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TreasuryRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TreasuryRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TreasuryRole.
func (c *TreasuryRoleClient) Update() *TreasuryRoleUpdate {
	mutation := newTreasuryRoleMutation(c.config, OpUpdate)
	return &TreasuryRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TreasuryRoleClient) UpdateOne(_m *TreasuryRole) *TreasuryRoleUpdateOne {
	mutation := newTreasuryRoleMutation(c.config, OpUpdateOne, withTreasuryRole(_m))
	return &TreasuryRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TreasuryRoleClient) UpdateOneID(id uuid.UUID) *TreasuryRoleUpdateOne {
	mutation := newTreasuryRoleMutation(c.config, OpUpdateOne, withTreasuryRoleID(id))
	return &TreasuryRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TreasuryRole.
func (c *TreasuryRoleClient) Delete() *TreasuryRoleDelete {
	mutation := newTreasuryRoleMutation(c.config, OpDelete)
	return &TreasuryRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TreasuryRoleClient) DeleteOne(_m *TreasuryRole) *TreasuryRoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TreasuryRoleClient) DeleteOneID(id uuid.UUID) *TreasuryRoleDeleteOne {
	builder := c.Delete().Where(treasuryrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TreasuryRoleDeleteOne{builder}
}

// Query returns a query builder for TreasuryRole.
func (c *TreasuryRoleClient) Query() *TreasuryRoleQuery {
	return &TreasuryRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTreasuryRole},
		inters: c.Interceptors(),
	}
}

// Get returns a TreasuryRole entity by its id.
func (c *TreasuryRoleClient) Get(ctx context.Context, id uuid.UUID) (*TreasuryRole, error) {
	return c.Query().Where(treasuryrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TreasuryRoleClient) GetX(ctx context.Context, id uuid.UUID) *TreasuryRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPermissions queries the permissions edge of a TreasuryRole.
func (c *TreasuryRoleClient) QueryPermissions(_m *TreasuryRole) *TreasuryPermissionQuery {
	query := (&TreasuryPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(treasuryrole.Table, treasuryrole.FieldID, id),
			sqlgraph.To(treasurypermission.Table, treasurypermission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, treasuryrole.PermissionsTable, treasuryrole.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserAssignments queries the user_assignments edge of a TreasuryRole.
func (c *TreasuryRoleClient) QueryUserAssignments(_m *TreasuryRole) *UserRoleAssignmentQuery {
	query := (&UserRoleAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(treasuryrole.Table, treasuryrole.FieldID, id),
			sqlgraph.To(userroleassignment.Table, userroleassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, treasuryrole.UserAssignmentsTable, treasuryrole.UserAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRolePermissions queries the role_permissions edge of a TreasuryRole.
func (c *TreasuryRoleClient) QueryRolePermissions(_m *TreasuryRole) *RolePermissionQuery {
	query := (&RolePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(treasuryrole.Table, treasuryrole.FieldID, id),
			sqlgraph.To(rolepermission.Table, rolepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, treasuryrole.RolePermissionsTable, treasuryrole.RolePermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TreasuryRoleClient) Hooks() []Hook {
	return c.hooks.TreasuryRole
}

// Interceptors returns the client interceptors.
func (c *TreasuryRoleClient) Interceptors() []Interceptor {
	return c.inters.TreasuryRole
}

func (c *TreasuryRoleClient) mutate(ctx context.Context, m *TreasuryRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TreasuryRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TreasuryRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TreasuryRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TreasuryRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TreasuryRole mutation op: %q", m.Op())
	}
}

// TreasuryUserClient is a client for the TreasuryUser schema.
type TreasuryUserClient struct {
	config
}

// NewTreasuryUserClient returns a client for the TreasuryUser from the given config.
func NewTreasuryUserClient(c config) *TreasuryUserClient {
	return &TreasuryUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `treasuryuser.Hooks(f(g(h())))`.
func (c *TreasuryUserClient) Use(hooks ...Hook) {
	c.hooks.TreasuryUser = append(c.hooks.TreasuryUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `treasuryuser.Intercept(f(g(h())))`.
func (c *TreasuryUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.TreasuryUser = append(c.inters.TreasuryUser, interceptors...)
}

// Create returns a builder for creating a TreasuryUser entity.
func (c *TreasuryUserClient) Create() *TreasuryUserCreate {
	mutation := newTreasuryUserMutation(c.config, OpCreate)
	return &TreasuryUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TreasuryUser entities.
func (c *TreasuryUserClient) CreateBulk(builders ...*TreasuryUserCreate) *TreasuryUserCreateBulk {
	return &TreasuryUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TreasuryUserClient) MapCreateBulk(slice any, setFunc func(*TreasuryUserCreate, int)) *TreasuryUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TreasuryUserCreateBulk{err: fmt.Errorf("calling to TreasuryUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TreasuryUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TreasuryUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TreasuryUser.
func (c *TreasuryUserClient) Update() *TreasuryUserUpdate {
	mutation := newTreasuryUserMutation(c.config, OpUpdate)
	return &TreasuryUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TreasuryUserClient) UpdateOne(_m *TreasuryUser) *TreasuryUserUpdateOne {
	mutation := newTreasuryUserMutation(c.config, OpUpdateOne, withTreasuryUser(_m))
	return &TreasuryUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TreasuryUserClient) UpdateOneID(id uuid.UUID) *TreasuryUserUpdateOne {
	mutation := newTreasuryUserMutation(c.config, OpUpdateOne, withTreasuryUserID(id))
	return &TreasuryUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TreasuryUser.
func (c *TreasuryUserClient) Delete() *TreasuryUserDelete {
	mutation := newTreasuryUserMutation(c.config, OpDelete)
	return &TreasuryUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TreasuryUserClient) DeleteOne(_m *TreasuryUser) *TreasuryUserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TreasuryUserClient) DeleteOneID(id uuid.UUID) *TreasuryUserDeleteOne {
	builder := c.Delete().Where(treasuryuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TreasuryUserDeleteOne{builder}
}

// Query returns a query builder for TreasuryUser.
func (c *TreasuryUserClient) Query() *TreasuryUserQuery {
	return &TreasuryUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTreasuryUser},
		inters: c.Interceptors(),
	}
}

// Get returns a TreasuryUser entity by its id.
func (c *TreasuryUserClient) Get(ctx context.Context, id uuid.UUID) (*TreasuryUser, error) {
	return c.Query().Where(treasuryuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TreasuryUserClient) GetX(ctx context.Context, id uuid.UUID) *TreasuryUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TreasuryUserClient) Hooks() []Hook {
	return c.hooks.TreasuryUser
}

// Interceptors returns the client interceptors.
func (c *TreasuryUserClient) Interceptors() []Interceptor {
	return c.inters.TreasuryUser
}

func (c *TreasuryUserClient) mutate(ctx context.Context, m *TreasuryUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TreasuryUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TreasuryUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TreasuryUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TreasuryUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TreasuryUser mutation op: %q", m.Op())
	}
}

// UserRoleAssignmentClient is a client for the UserRoleAssignment schema.
type UserRoleAssignmentClient struct {
	config
}

// NewUserRoleAssignmentClient returns a client for the UserRoleAssignment from the given config.
func NewUserRoleAssignmentClient(c config) *UserRoleAssignmentClient {
	return &UserRoleAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userroleassignment.Hooks(f(g(h())))`.
func (c *UserRoleAssignmentClient) Use(hooks ...Hook) {
	c.hooks.UserRoleAssignment = append(c.hooks.UserRoleAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userroleassignment.Intercept(f(g(h())))`.
func (c *UserRoleAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRoleAssignment = append(c.inters.UserRoleAssignment, interceptors...)
}

// Create returns a builder for creating a UserRoleAssignment entity.
func (c *UserRoleAssignmentClient) Create() *UserRoleAssignmentCreate {
	mutation := newUserRoleAssignmentMutation(c.config, OpCreate)
	return &UserRoleAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRoleAssignment entities.
func (c *UserRoleAssignmentClient) CreateBulk(builders ...*UserRoleAssignmentCreate) *UserRoleAssignmentCreateBulk {
	return &UserRoleAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleAssignmentClient) MapCreateBulk(slice any, setFunc func(*UserRoleAssignmentCreate, int)) *UserRoleAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleAssignmentCreateBulk{err: fmt.Errorf("calling to UserRoleAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRoleAssignment.
func (c *UserRoleAssignmentClient) Update() *UserRoleAssignmentUpdate {
	mutation := newUserRoleAssignmentMutation(c.config, OpUpdate)
	return &UserRoleAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleAssignmentClient) UpdateOne(_m *UserRoleAssignment) *UserRoleAssignmentUpdateOne {
	mutation := newUserRoleAssignmentMutation(c.config, OpUpdateOne, withUserRoleAssignment(_m))
	return &UserRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleAssignmentClient) UpdateOneID(id uuid.UUID) *UserRoleAssignmentUpdateOne {
	mutation := newUserRoleAssignmentMutation(c.config, OpUpdateOne, withUserRoleAssignmentID(id))
	return &UserRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRoleAssignment.
func (c *UserRoleAssignmentClient) Delete() *UserRoleAssignmentDelete {
	mutation := newUserRoleAssignmentMutation(c.config, OpDelete)
	return &UserRoleAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleAssignmentClient) DeleteOne(_m *UserRoleAssignment) *UserRoleAssignmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleAssignmentClient) DeleteOneID(id uuid.UUID) *UserRoleAssignmentDeleteOne {
	builder := c.Delete().Where(userroleassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleAssignmentDeleteOne{builder}
}

// Query returns a query builder for UserRoleAssignment.
func (c *UserRoleAssignmentClient) Query() *UserRoleAssignmentQuery {
	return &UserRoleAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRoleAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRoleAssignment entity by its id.
func (c *UserRoleAssignmentClient) Get(ctx context.Context, id uuid.UUID) (*UserRoleAssignment, error) {
	return c.Query().Where(userroleassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleAssignmentClient) GetX(ctx context.Context, id uuid.UUID) *UserRoleAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserRoleAssignment.
func (c *UserRoleAssignmentClient) QueryUser(_m *UserRoleAssignment) *TreasuryUserQuery {
	query := (&TreasuryUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userroleassignment.Table, userroleassignment.FieldID, id),
			sqlgraph.To(treasuryuser.Table, treasuryuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userroleassignment.UserTable, userroleassignment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRole queries the role edge of a UserRoleAssignment.
func (c *UserRoleAssignmentClient) QueryRole(_m *UserRoleAssignment) *TreasuryRoleQuery {
	query := (&TreasuryRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userroleassignment.Table, userroleassignment.FieldID, id),
			sqlgraph.To(treasuryrole.Table, treasuryrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userroleassignment.RoleTable, userroleassignment.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserRoleAssignmentClient) Hooks() []Hook {
	return c.hooks.UserRoleAssignment
}

// Interceptors returns the client interceptors.
func (c *UserRoleAssignmentClient) Interceptors() []Interceptor {
	return c.inters.UserRoleAssignment
}

func (c *UserRoleAssignmentClient) mutate(ctx context.Context, m *UserRoleAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserRoleAssignment mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ChartOfAccount, Invoice, LedgerTransaction, OutboxEvent, PaymentIntent,
		PaymentTransaction, RolePermission, TreasuryPermission, TreasuryRole,
		TreasuryUser, UserRoleAssignment []ent.Hook
	}
	inters struct {
		ChartOfAccount, Invoice, LedgerTransaction, OutboxEvent, PaymentIntent,
		PaymentTransaction, RolePermission, TreasuryPermission, TreasuryRole,
		TreasuryUser, UserRoleAssignment []ent.Interceptor
	}
)
