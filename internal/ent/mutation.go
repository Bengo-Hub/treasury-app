// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/bengobox/treasury-api/internal/ent/chartofaccount"
	"github.com/bengobox/treasury-api/internal/ent/invoice"
	"github.com/bengobox/treasury-api/internal/ent/ledgertransaction"
	"github.com/bengobox/treasury-api/internal/ent/outboxevent"
	"github.com/bengobox/treasury-api/internal/ent/paymentintent"
	"github.com/bengobox/treasury-api/internal/ent/paymenttransaction"
	"github.com/bengobox/treasury-api/internal/ent/predicate"
	"github.com/bengobox/treasury-api/internal/ent/rolepermission"
	"github.com/bengobox/treasury-api/internal/ent/treasurypermission"
	"github.com/bengobox/treasury-api/internal/ent/treasuryrole"
	"github.com/bengobox/treasury-api/internal/ent/treasuryuser"
	"github.com/bengobox/treasury-api/internal/ent/userroleassignment"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeChartOfAccount     = "ChartOfAccount"
	TypeInvoice            = "Invoice"
	TypeLedgerTransaction  = "LedgerTransaction"
	TypeOutboxEvent        = "OutboxEvent"
	TypePaymentIntent      = "PaymentIntent"
	TypePaymentTransaction = "PaymentTransaction"
	TypeRolePermission     = "RolePermission"
	TypeTreasuryPermission = "TreasuryPermission"
	TypeTreasuryRole       = "TreasuryRole"
	TypeTreasuryUser       = "TreasuryUser"
	TypeUserRoleAssignment = "UserRoleAssignment"
)

// ChartOfAccountMutation represents an operation that mutates the ChartOfAccount nodes in the graph.
type ChartOfAccountMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	tenant_id       *uuid.UUID
	account_code    *string
	account_name    *string
	account_type    *string
	is_active       *bool
	description     *string
	metadata        *map[string]interface{}
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	parent          *uuid.UUID
	clearedparent   bool
	children        map[uuid.UUID]struct{}
	removedchildren map[uuid.UUID]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*ChartOfAccount, error)
	predicates      []predicate.ChartOfAccount
}

var _ ent.Mutation = (*ChartOfAccountMutation)(nil)

// chartofaccountOption allows management of the mutation configuration using functional options.
type chartofaccountOption func(*ChartOfAccountMutation)

// newChartOfAccountMutation creates new mutation for the ChartOfAccount entity.
func newChartOfAccountMutation(c config, op Op, opts ...chartofaccountOption) *ChartOfAccountMutation {
	m := &ChartOfAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeChartOfAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChartOfAccountID sets the ID field of the mutation.
func withChartOfAccountID(id uuid.UUID) chartofaccountOption {
	return func(m *ChartOfAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *ChartOfAccount
		)
		m.oldValue = func(ctx context.Context) (*ChartOfAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChartOfAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChartOfAccount sets the old ChartOfAccount of the mutation.
func withChartOfAccount(node *ChartOfAccount) chartofaccountOption {
	return func(m *ChartOfAccountMutation) {
		m.oldValue = func(context.Context) (*ChartOfAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChartOfAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChartOfAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChartOfAccount entities.
func (m *ChartOfAccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChartOfAccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChartOfAccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChartOfAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ChartOfAccountMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ChartOfAccountMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ChartOfAccountMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetAccountCode sets the "account_code" field.
func (m *ChartOfAccountMutation) SetAccountCode(s string) {
	m.account_code = &s
}

// AccountCode returns the value of the "account_code" field in the mutation.
func (m *ChartOfAccountMutation) AccountCode() (r string, exists bool) {
	v := m.account_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountCode returns the old "account_code" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldAccountCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountCode: %w", err)
	}
	return oldValue.AccountCode, nil
}

// ResetAccountCode resets all changes to the "account_code" field.
func (m *ChartOfAccountMutation) ResetAccountCode() {
	m.account_code = nil
}

// SetAccountName sets the "account_name" field.
func (m *ChartOfAccountMutation) SetAccountName(s string) {
	m.account_name = &s
}

// AccountName returns the value of the "account_name" field in the mutation.
func (m *ChartOfAccountMutation) AccountName() (r string, exists bool) {
	v := m.account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountName returns the old "account_name" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountName: %w", err)
	}
	return oldValue.AccountName, nil
}

// ResetAccountName resets all changes to the "account_name" field.
func (m *ChartOfAccountMutation) ResetAccountName() {
	m.account_name = nil
}

// SetAccountType sets the "account_type" field.
func (m *ChartOfAccountMutation) SetAccountType(s string) {
	m.account_type = &s
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *ChartOfAccountMutation) AccountType() (r string, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldAccountType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *ChartOfAccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetParentID sets the "parent_id" field.
func (m *ChartOfAccountMutation) SetParentID(u uuid.UUID) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *ChartOfAccountMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *ChartOfAccountMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[chartofaccount.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *ChartOfAccountMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[chartofaccount.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *ChartOfAccountMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, chartofaccount.FieldParentID)
}

// SetIsActive sets the "is_active" field.
func (m *ChartOfAccountMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ChartOfAccountMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ChartOfAccountMutation) ResetIsActive() {
	m.is_active = nil
}

// SetDescription sets the "description" field.
func (m *ChartOfAccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChartOfAccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChartOfAccountMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[chartofaccount.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChartOfAccountMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[chartofaccount.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChartOfAccountMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, chartofaccount.FieldDescription)
}

// SetMetadata sets the "metadata" field.
func (m *ChartOfAccountMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ChartOfAccountMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ChartOfAccountMutation) ResetMetadata() {
	m.metadata = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChartOfAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChartOfAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChartOfAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChartOfAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChartOfAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChartOfAccount entity.
// If the ChartOfAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChartOfAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChartOfAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearParent clears the "parent" edge to the ChartOfAccount entity.
func (m *ChartOfAccountMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[chartofaccount.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the ChartOfAccount entity was cleared.
func (m *ChartOfAccountMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ChartOfAccountMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ChartOfAccountMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ChartOfAccount entity by ids.
func (m *ChartOfAccountMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ChartOfAccount entity.
func (m *ChartOfAccountMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ChartOfAccount entity was cleared.
func (m *ChartOfAccountMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ChartOfAccount entity by IDs.
func (m *ChartOfAccountMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ChartOfAccount entity.
func (m *ChartOfAccountMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ChartOfAccountMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ChartOfAccountMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the ChartOfAccountMutation builder.
func (m *ChartOfAccountMutation) Where(ps ...predicate.ChartOfAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChartOfAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChartOfAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChartOfAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChartOfAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChartOfAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChartOfAccount).
func (m *ChartOfAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChartOfAccountMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.tenant_id != nil {
		fields = append(fields, chartofaccount.FieldTenantID)
	}
	if m.account_code != nil {
		fields = append(fields, chartofaccount.FieldAccountCode)
	}
	if m.account_name != nil {
		fields = append(fields, chartofaccount.FieldAccountName)
	}
	if m.account_type != nil {
		fields = append(fields, chartofaccount.FieldAccountType)
	}
	if m.parent != nil {
		fields = append(fields, chartofaccount.FieldParentID)
	}
	if m.is_active != nil {
		fields = append(fields, chartofaccount.FieldIsActive)
	}
	if m.description != nil {
		fields = append(fields, chartofaccount.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, chartofaccount.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, chartofaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chartofaccount.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChartOfAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chartofaccount.FieldTenantID:
		return m.TenantID()
	case chartofaccount.FieldAccountCode:
		return m.AccountCode()
	case chartofaccount.FieldAccountName:
		return m.AccountName()
	case chartofaccount.FieldAccountType:
		return m.AccountType()
	case chartofaccount.FieldParentID:
		return m.ParentID()
	case chartofaccount.FieldIsActive:
		return m.IsActive()
	case chartofaccount.FieldDescription:
		return m.Description()
	case chartofaccount.FieldMetadata:
		return m.Metadata()
	case chartofaccount.FieldCreatedAt:
		return m.CreatedAt()
	case chartofaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChartOfAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chartofaccount.FieldTenantID:
		return m.OldTenantID(ctx)
	case chartofaccount.FieldAccountCode:
		return m.OldAccountCode(ctx)
	case chartofaccount.FieldAccountName:
		return m.OldAccountName(ctx)
	case chartofaccount.FieldAccountType:
		return m.OldAccountType(ctx)
	case chartofaccount.FieldParentID:
		return m.OldParentID(ctx)
	case chartofaccount.FieldIsActive:
		return m.OldIsActive(ctx)
	case chartofaccount.FieldDescription:
		return m.OldDescription(ctx)
	case chartofaccount.FieldMetadata:
		return m.OldMetadata(ctx)
	case chartofaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chartofaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChartOfAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChartOfAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chartofaccount.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case chartofaccount.FieldAccountCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountCode(v)
		return nil
	case chartofaccount.FieldAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountName(v)
		return nil
	case chartofaccount.FieldAccountType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case chartofaccount.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case chartofaccount.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case chartofaccount.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case chartofaccount.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case chartofaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chartofaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChartOfAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChartOfAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChartOfAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChartOfAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChartOfAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChartOfAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chartofaccount.FieldParentID) {
		fields = append(fields, chartofaccount.FieldParentID)
	}
	if m.FieldCleared(chartofaccount.FieldDescription) {
		fields = append(fields, chartofaccount.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChartOfAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChartOfAccountMutation) ClearField(name string) error {
	switch name {
	case chartofaccount.FieldParentID:
		m.ClearParentID()
		return nil
	case chartofaccount.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ChartOfAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChartOfAccountMutation) ResetField(name string) error {
	switch name {
	case chartofaccount.FieldTenantID:
		m.ResetTenantID()
		return nil
	case chartofaccount.FieldAccountCode:
		m.ResetAccountCode()
		return nil
	case chartofaccount.FieldAccountName:
		m.ResetAccountName()
		return nil
	case chartofaccount.FieldAccountType:
		m.ResetAccountType()
		return nil
	case chartofaccount.FieldParentID:
		m.ResetParentID()
		return nil
	case chartofaccount.FieldIsActive:
		m.ResetIsActive()
		return nil
	case chartofaccount.FieldDescription:
		m.ResetDescription()
		return nil
	case chartofaccount.FieldMetadata:
		m.ResetMetadata()
		return nil
	case chartofaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chartofaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ChartOfAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChartOfAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, chartofaccount.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, chartofaccount.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChartOfAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chartofaccount.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case chartofaccount.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChartOfAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildren != nil {
		edges = append(edges, chartofaccount.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChartOfAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chartofaccount.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChartOfAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, chartofaccount.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, chartofaccount.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChartOfAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case chartofaccount.EdgeParent:
		return m.clearedparent
	case chartofaccount.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChartOfAccountMutation) ClearEdge(name string) error {
	switch name {
	case chartofaccount.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ChartOfAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChartOfAccountMutation) ResetEdge(name string) error {
	switch name {
	case chartofaccount.EdgeParent:
		m.ResetParent()
		return nil
	case chartofaccount.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown ChartOfAccount edge %s", name)
}

// InvoiceMutation represents an operation that mutates the Invoice nodes in the graph.
type InvoiceMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	tenant_id       *uuid.UUID
	invoice_number  *string
	customer_id     *uuid.UUID
	invoice_type    *string
	invoice_date    *time.Time
	due_date        *time.Time
	subtotal        *decimal.Decimal
	addsubtotal     *decimal.Decimal
	tax_amount      *decimal.Decimal
	addtax_amount   *decimal.Decimal
	total_amount    *decimal.Decimal
	addtotal_amount *decimal.Decimal
	currency        *string
	status          *string
	payment_status  *string
	reference_id    *uuid.UUID
	reference_type  *string
	metadata        *map[string]interface{}
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Invoice, error)
	predicates      []predicate.Invoice
}

var _ ent.Mutation = (*InvoiceMutation)(nil)

// invoiceOption allows management of the mutation configuration using functional options.
type invoiceOption func(*InvoiceMutation)

// newInvoiceMutation creates new mutation for the Invoice entity.
func newInvoiceMutation(c config, op Op, opts ...invoiceOption) *InvoiceMutation {
	m := &InvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceID sets the ID field of the mutation.
func withInvoiceID(id uuid.UUID) invoiceOption {
	return func(m *InvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Invoice
		)
		m.oldValue = func(ctx context.Context) (*Invoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoice sets the old Invoice of the mutation.
func withInvoice(node *Invoice) invoiceOption {
	return func(m *InvoiceMutation) {
		m.oldValue = func(context.Context) (*Invoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invoice entities.
func (m *InvoiceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *InvoiceMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *InvoiceMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *InvoiceMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetInvoiceNumber sets the "invoice_number" field.
func (m *InvoiceMutation) SetInvoiceNumber(s string) {
	m.invoice_number = &s
}

// InvoiceNumber returns the value of the "invoice_number" field in the mutation.
func (m *InvoiceMutation) InvoiceNumber() (r string, exists bool) {
	v := m.invoice_number
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceNumber returns the old "invoice_number" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldInvoiceNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceNumber: %w", err)
	}
	return oldValue.InvoiceNumber, nil
}

// ResetInvoiceNumber resets all changes to the "invoice_number" field.
func (m *InvoiceMutation) ResetInvoiceNumber() {
	m.invoice_number = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *InvoiceMutation) SetCustomerID(u uuid.UUID) {
	m.customer_id = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *InvoiceMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *InvoiceMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[invoice.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *InvoiceMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *InvoiceMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, invoice.FieldCustomerID)
}

// SetInvoiceType sets the "invoice_type" field.
func (m *InvoiceMutation) SetInvoiceType(s string) {
	m.invoice_type = &s
}

// InvoiceType returns the value of the "invoice_type" field in the mutation.
func (m *InvoiceMutation) InvoiceType() (r string, exists bool) {
	v := m.invoice_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceType returns the old "invoice_type" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldInvoiceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceType: %w", err)
	}
	return oldValue.InvoiceType, nil
}

// ResetInvoiceType resets all changes to the "invoice_type" field.
func (m *InvoiceMutation) ResetInvoiceType() {
	m.invoice_type = nil
}

// SetInvoiceDate sets the "invoice_date" field.
func (m *InvoiceMutation) SetInvoiceDate(t time.Time) {
	m.invoice_date = &t
}

// InvoiceDate returns the value of the "invoice_date" field in the mutation.
func (m *InvoiceMutation) InvoiceDate() (r time.Time, exists bool) {
	v := m.invoice_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDate returns the old "invoice_date" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldInvoiceDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDate: %w", err)
	}
	return oldValue.InvoiceDate, nil
}

// ResetInvoiceDate resets all changes to the "invoice_date" field.
func (m *InvoiceMutation) ResetInvoiceDate() {
	m.invoice_date = nil
}

// SetDueDate sets the "due_date" field.
func (m *InvoiceMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *InvoiceMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *InvoiceMutation) ResetDueDate() {
	m.due_date = nil
}

// SetSubtotal sets the "subtotal" field.
func (m *InvoiceMutation) SetSubtotal(d decimal.Decimal) {
	m.subtotal = &d
	m.addsubtotal = nil
}

// Subtotal returns the value of the "subtotal" field in the mutation.
func (m *InvoiceMutation) Subtotal() (r decimal.Decimal, exists bool) {
	v := m.subtotal
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtotal returns the old "subtotal" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldSubtotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtotal: %w", err)
	}
	return oldValue.Subtotal, nil
}

// AddSubtotal adds d to the "subtotal" field.
func (m *InvoiceMutation) AddSubtotal(d decimal.Decimal) {
	if m.addsubtotal != nil {
		*m.addsubtotal = m.addsubtotal.Add(d)
	} else {
		m.addsubtotal = &d
	}
}

// AddedSubtotal returns the value that was added to the "subtotal" field in this mutation.
func (m *InvoiceMutation) AddedSubtotal() (r decimal.Decimal, exists bool) {
	v := m.addsubtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubtotal resets all changes to the "subtotal" field.
func (m *InvoiceMutation) ResetSubtotal() {
	m.subtotal = nil
	m.addsubtotal = nil
}

// SetTaxAmount sets the "tax_amount" field.
func (m *InvoiceMutation) SetTaxAmount(d decimal.Decimal) {
	m.tax_amount = &d
	m.addtax_amount = nil
}

// TaxAmount returns the value of the "tax_amount" field in the mutation.
func (m *InvoiceMutation) TaxAmount() (r decimal.Decimal, exists bool) {
	v := m.tax_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAmount returns the old "tax_amount" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTaxAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAmount: %w", err)
	}
	return oldValue.TaxAmount, nil
}

// AddTaxAmount adds d to the "tax_amount" field.
func (m *InvoiceMutation) AddTaxAmount(d decimal.Decimal) {
	if m.addtax_amount != nil {
		*m.addtax_amount = m.addtax_amount.Add(d)
	} else {
		m.addtax_amount = &d
	}
}

// AddedTaxAmount returns the value that was added to the "tax_amount" field in this mutation.
func (m *InvoiceMutation) AddedTaxAmount() (r decimal.Decimal, exists bool) {
	v := m.addtax_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaxAmount resets all changes to the "tax_amount" field.
func (m *InvoiceMutation) ResetTaxAmount() {
	m.tax_amount = nil
	m.addtax_amount = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *InvoiceMutation) SetTotalAmount(d decimal.Decimal) {
	m.total_amount = &d
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *InvoiceMutation) TotalAmount() (r decimal.Decimal, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTotalAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds d to the "total_amount" field.
func (m *InvoiceMutation) AddTotalAmount(d decimal.Decimal) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount = m.addtotal_amount.Add(d)
	} else {
		m.addtotal_amount = &d
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *InvoiceMutation) AddedTotalAmount() (r decimal.Decimal, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *InvoiceMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetCurrency sets the "currency" field.
func (m *InvoiceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *InvoiceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *InvoiceMutation) ResetCurrency() {
	m.currency = nil
}

// SetStatus sets the "status" field.
func (m *InvoiceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InvoiceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InvoiceMutation) ResetStatus() {
	m.status = nil
}

// SetPaymentStatus sets the "payment_status" field.
func (m *InvoiceMutation) SetPaymentStatus(s string) {
	m.payment_status = &s
}

// PaymentStatus returns the value of the "payment_status" field in the mutation.
func (m *InvoiceMutation) PaymentStatus() (r string, exists bool) {
	v := m.payment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old "payment_status" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldPaymentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// ResetPaymentStatus resets all changes to the "payment_status" field.
func (m *InvoiceMutation) ResetPaymentStatus() {
	m.payment_status = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *InvoiceMutation) SetReferenceID(u uuid.UUID) {
	m.reference_id = &u
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *InvoiceMutation) ReferenceID() (r uuid.UUID, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldReferenceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ClearReferenceID clears the value of the "reference_id" field.
func (m *InvoiceMutation) ClearReferenceID() {
	m.reference_id = nil
	m.clearedFields[invoice.FieldReferenceID] = struct{}{}
}

// ReferenceIDCleared returns if the "reference_id" field was cleared in this mutation.
func (m *InvoiceMutation) ReferenceIDCleared() bool {
	_, ok := m.clearedFields[invoice.FieldReferenceID]
	return ok
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *InvoiceMutation) ResetReferenceID() {
	m.reference_id = nil
	delete(m.clearedFields, invoice.FieldReferenceID)
}

// SetReferenceType sets the "reference_type" field.
func (m *InvoiceMutation) SetReferenceType(s string) {
	m.reference_type = &s
}

// ReferenceType returns the value of the "reference_type" field in the mutation.
func (m *InvoiceMutation) ReferenceType() (r string, exists bool) {
	v := m.reference_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceType returns the old "reference_type" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldReferenceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceType: %w", err)
	}
	return oldValue.ReferenceType, nil
}

// ClearReferenceType clears the value of the "reference_type" field.
func (m *InvoiceMutation) ClearReferenceType() {
	m.reference_type = nil
	m.clearedFields[invoice.FieldReferenceType] = struct{}{}
}

// ReferenceTypeCleared returns if the "reference_type" field was cleared in this mutation.
func (m *InvoiceMutation) ReferenceTypeCleared() bool {
	_, ok := m.clearedFields[invoice.FieldReferenceType]
	return ok
}

// ResetReferenceType resets all changes to the "reference_type" field.
func (m *InvoiceMutation) ResetReferenceType() {
	m.reference_type = nil
	delete(m.clearedFields, invoice.FieldReferenceType)
}

// SetMetadata sets the "metadata" field.
func (m *InvoiceMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *InvoiceMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *InvoiceMutation) ResetMetadata() {
	m.metadata = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the InvoiceMutation builder.
func (m *InvoiceMutation) Where(ps ...predicate.Invoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invoice).
func (m *InvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.tenant_id != nil {
		fields = append(fields, invoice.FieldTenantID)
	}
	if m.invoice_number != nil {
		fields = append(fields, invoice.FieldInvoiceNumber)
	}
	if m.customer_id != nil {
		fields = append(fields, invoice.FieldCustomerID)
	}
	if m.invoice_type != nil {
		fields = append(fields, invoice.FieldInvoiceType)
	}
	if m.invoice_date != nil {
		fields = append(fields, invoice.FieldInvoiceDate)
	}
	if m.due_date != nil {
		fields = append(fields, invoice.FieldDueDate)
	}
	if m.subtotal != nil {
		fields = append(fields, invoice.FieldSubtotal)
	}
	if m.tax_amount != nil {
		fields = append(fields, invoice.FieldTaxAmount)
	}
	if m.total_amount != nil {
		fields = append(fields, invoice.FieldTotalAmount)
	}
	if m.currency != nil {
		fields = append(fields, invoice.FieldCurrency)
	}
	if m.status != nil {
		fields = append(fields, invoice.FieldStatus)
	}
	if m.payment_status != nil {
		fields = append(fields, invoice.FieldPaymentStatus)
	}
	if m.reference_id != nil {
		fields = append(fields, invoice.FieldReferenceID)
	}
	if m.reference_type != nil {
		fields = append(fields, invoice.FieldReferenceType)
	}
	if m.metadata != nil {
		fields = append(fields, invoice.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, invoice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoice.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldTenantID:
		return m.TenantID()
	case invoice.FieldInvoiceNumber:
		return m.InvoiceNumber()
	case invoice.FieldCustomerID:
		return m.CustomerID()
	case invoice.FieldInvoiceType:
		return m.InvoiceType()
	case invoice.FieldInvoiceDate:
		return m.InvoiceDate()
	case invoice.FieldDueDate:
		return m.DueDate()
	case invoice.FieldSubtotal:
		return m.Subtotal()
	case invoice.FieldTaxAmount:
		return m.TaxAmount()
	case invoice.FieldTotalAmount:
		return m.TotalAmount()
	case invoice.FieldCurrency:
		return m.Currency()
	case invoice.FieldStatus:
		return m.Status()
	case invoice.FieldPaymentStatus:
		return m.PaymentStatus()
	case invoice.FieldReferenceID:
		return m.ReferenceID()
	case invoice.FieldReferenceType:
		return m.ReferenceType()
	case invoice.FieldMetadata:
		return m.Metadata()
	case invoice.FieldCreatedAt:
		return m.CreatedAt()
	case invoice.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoice.FieldTenantID:
		return m.OldTenantID(ctx)
	case invoice.FieldInvoiceNumber:
		return m.OldInvoiceNumber(ctx)
	case invoice.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case invoice.FieldInvoiceType:
		return m.OldInvoiceType(ctx)
	case invoice.FieldInvoiceDate:
		return m.OldInvoiceDate(ctx)
	case invoice.FieldDueDate:
		return m.OldDueDate(ctx)
	case invoice.FieldSubtotal:
		return m.OldSubtotal(ctx)
	case invoice.FieldTaxAmount:
		return m.OldTaxAmount(ctx)
	case invoice.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case invoice.FieldCurrency:
		return m.OldCurrency(ctx)
	case invoice.FieldStatus:
		return m.OldStatus(ctx)
	case invoice.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	case invoice.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case invoice.FieldReferenceType:
		return m.OldReferenceType(ctx)
	case invoice.FieldMetadata:
		return m.OldMetadata(ctx)
	case invoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Invoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case invoice.FieldInvoiceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceNumber(v)
		return nil
	case invoice.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case invoice.FieldInvoiceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceType(v)
		return nil
	case invoice.FieldInvoiceDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDate(v)
		return nil
	case invoice.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case invoice.FieldSubtotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtotal(v)
		return nil
	case invoice.FieldTaxAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAmount(v)
		return nil
	case invoice.FieldTotalAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case invoice.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case invoice.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case invoice.FieldPaymentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	case invoice.FieldReferenceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case invoice.FieldReferenceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceType(v)
		return nil
	case invoice.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case invoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addsubtotal != nil {
		fields = append(fields, invoice.FieldSubtotal)
	}
	if m.addtax_amount != nil {
		fields = append(fields, invoice.FieldTaxAmount)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, invoice.FieldTotalAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldSubtotal:
		return m.AddedSubtotal()
	case invoice.FieldTaxAmount:
		return m.AddedTaxAmount()
	case invoice.FieldTotalAmount:
		return m.AddedTotalAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldSubtotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubtotal(v)
		return nil
	case invoice.FieldTaxAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAmount(v)
		return nil
	case invoice.FieldTotalAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoice.FieldCustomerID) {
		fields = append(fields, invoice.FieldCustomerID)
	}
	if m.FieldCleared(invoice.FieldReferenceID) {
		fields = append(fields, invoice.FieldReferenceID)
	}
	if m.FieldCleared(invoice.FieldReferenceType) {
		fields = append(fields, invoice.FieldReferenceType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceMutation) ClearField(name string) error {
	switch name {
	case invoice.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case invoice.FieldReferenceID:
		m.ClearReferenceID()
		return nil
	case invoice.FieldReferenceType:
		m.ClearReferenceType()
		return nil
	}
	return fmt.Errorf("unknown Invoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceMutation) ResetField(name string) error {
	switch name {
	case invoice.FieldTenantID:
		m.ResetTenantID()
		return nil
	case invoice.FieldInvoiceNumber:
		m.ResetInvoiceNumber()
		return nil
	case invoice.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case invoice.FieldInvoiceType:
		m.ResetInvoiceType()
		return nil
	case invoice.FieldInvoiceDate:
		m.ResetInvoiceDate()
		return nil
	case invoice.FieldDueDate:
		m.ResetDueDate()
		return nil
	case invoice.FieldSubtotal:
		m.ResetSubtotal()
		return nil
	case invoice.FieldTaxAmount:
		m.ResetTaxAmount()
		return nil
	case invoice.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case invoice.FieldCurrency:
		m.ResetCurrency()
		return nil
	case invoice.FieldStatus:
		m.ResetStatus()
		return nil
	case invoice.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	case invoice.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case invoice.FieldReferenceType:
		m.ResetReferenceType()
		return nil
	case invoice.FieldMetadata:
		m.ResetMetadata()
		return nil
	case invoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Invoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Invoice edge %s", name)
}

// LedgerTransactionMutation represents an operation that mutates the LedgerTransaction nodes in the graph.
type LedgerTransactionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	tenant_id        *uuid.UUID
	journal_entry_id *uuid.UUID
	debit_amount     *decimal.Decimal
	adddebit_amount  *decimal.Decimal
	credit_amount    *decimal.Decimal
	addcredit_amount *decimal.Decimal
	currency         *string
	exchange_rate    *decimal.Decimal
	addexchange_rate *decimal.Decimal
	reference_type   *string
	reference_id     *uuid.UUID
	transaction_date *time.Time
	description      *string
	metadata         *map[string]interface{}
	created_at       *time.Time
	clearedFields    map[string]struct{}
	account          *uuid.UUID
	clearedaccount   bool
	done             bool
	oldValue         func(context.Context) (*LedgerTransaction, error)
	predicates       []predicate.LedgerTransaction
}

var _ ent.Mutation = (*LedgerTransactionMutation)(nil)

// ledgertransactionOption allows management of the mutation configuration using functional options.
type ledgertransactionOption func(*LedgerTransactionMutation)

// newLedgerTransactionMutation creates new mutation for the LedgerTransaction entity.
func newLedgerTransactionMutation(c config, op Op, opts ...ledgertransactionOption) *LedgerTransactionMutation {
	m := &LedgerTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeLedgerTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLedgerTransactionID sets the ID field of the mutation.
func withLedgerTransactionID(id uuid.UUID) ledgertransactionOption {
	return func(m *LedgerTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *LedgerTransaction
		)
		m.oldValue = func(ctx context.Context) (*LedgerTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LedgerTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLedgerTransaction sets the old LedgerTransaction of the mutation.
func withLedgerTransaction(node *LedgerTransaction) ledgertransactionOption {
	return func(m *LedgerTransactionMutation) {
		m.oldValue = func(context.Context) (*LedgerTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LedgerTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LedgerTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LedgerTransaction entities.
func (m *LedgerTransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LedgerTransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LedgerTransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LedgerTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *LedgerTransactionMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LedgerTransactionMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LedgerTransactionMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetAccountID sets the "account_id" field.
func (m *LedgerTransactionMutation) SetAccountID(u uuid.UUID) {
	m.account = &u
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *LedgerTransactionMutation) AccountID() (r uuid.UUID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldAccountID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *LedgerTransactionMutation) ResetAccountID() {
	m.account = nil
}

// SetJournalEntryID sets the "journal_entry_id" field.
func (m *LedgerTransactionMutation) SetJournalEntryID(u uuid.UUID) {
	m.journal_entry_id = &u
}

// JournalEntryID returns the value of the "journal_entry_id" field in the mutation.
func (m *LedgerTransactionMutation) JournalEntryID() (r uuid.UUID, exists bool) {
	v := m.journal_entry_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJournalEntryID returns the old "journal_entry_id" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldJournalEntryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJournalEntryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJournalEntryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJournalEntryID: %w", err)
	}
	return oldValue.JournalEntryID, nil
}

// ClearJournalEntryID clears the value of the "journal_entry_id" field.
func (m *LedgerTransactionMutation) ClearJournalEntryID() {
	m.journal_entry_id = nil
	m.clearedFields[ledgertransaction.FieldJournalEntryID] = struct{}{}
}

// JournalEntryIDCleared returns if the "journal_entry_id" field was cleared in this mutation.
func (m *LedgerTransactionMutation) JournalEntryIDCleared() bool {
	_, ok := m.clearedFields[ledgertransaction.FieldJournalEntryID]
	return ok
}

// ResetJournalEntryID resets all changes to the "journal_entry_id" field.
func (m *LedgerTransactionMutation) ResetJournalEntryID() {
	m.journal_entry_id = nil
	delete(m.clearedFields, ledgertransaction.FieldJournalEntryID)
}

// SetDebitAmount sets the "debit_amount" field.
func (m *LedgerTransactionMutation) SetDebitAmount(d decimal.Decimal) {
	m.debit_amount = &d
	m.adddebit_amount = nil
}

// DebitAmount returns the value of the "debit_amount" field in the mutation.
func (m *LedgerTransactionMutation) DebitAmount() (r decimal.Decimal, exists bool) {
	v := m.debit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDebitAmount returns the old "debit_amount" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldDebitAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebitAmount: %w", err)
	}
	return oldValue.DebitAmount, nil
}

// AddDebitAmount adds d to the "debit_amount" field.
func (m *LedgerTransactionMutation) AddDebitAmount(d decimal.Decimal) {
	if m.adddebit_amount != nil {
		*m.adddebit_amount = m.adddebit_amount.Add(d)
	} else {
		m.adddebit_amount = &d
	}
}

// AddedDebitAmount returns the value that was added to the "debit_amount" field in this mutation.
func (m *LedgerTransactionMutation) AddedDebitAmount() (r decimal.Decimal, exists bool) {
	v := m.adddebit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDebitAmount resets all changes to the "debit_amount" field.
func (m *LedgerTransactionMutation) ResetDebitAmount() {
	m.debit_amount = nil
	m.adddebit_amount = nil
}

// SetCreditAmount sets the "credit_amount" field.
func (m *LedgerTransactionMutation) SetCreditAmount(d decimal.Decimal) {
	m.credit_amount = &d
	m.addcredit_amount = nil
}

// CreditAmount returns the value of the "credit_amount" field in the mutation.
func (m *LedgerTransactionMutation) CreditAmount() (r decimal.Decimal, exists bool) {
	v := m.credit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAmount returns the old "credit_amount" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldCreditAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAmount: %w", err)
	}
	return oldValue.CreditAmount, nil
}

// AddCreditAmount adds d to the "credit_amount" field.
func (m *LedgerTransactionMutation) AddCreditAmount(d decimal.Decimal) {
	if m.addcredit_amount != nil {
		*m.addcredit_amount = m.addcredit_amount.Add(d)
	} else {
		m.addcredit_amount = &d
	}
}

// AddedCreditAmount returns the value that was added to the "credit_amount" field in this mutation.
func (m *LedgerTransactionMutation) AddedCreditAmount() (r decimal.Decimal, exists bool) {
	v := m.addcredit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditAmount resets all changes to the "credit_amount" field.
func (m *LedgerTransactionMutation) ResetCreditAmount() {
	m.credit_amount = nil
	m.addcredit_amount = nil
}

// SetCurrency sets the "currency" field.
func (m *LedgerTransactionMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *LedgerTransactionMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *LedgerTransactionMutation) ResetCurrency() {
	m.currency = nil
}

// SetExchangeRate sets the "exchange_rate" field.
func (m *LedgerTransactionMutation) SetExchangeRate(d decimal.Decimal) {
	m.exchange_rate = &d
	m.addexchange_rate = nil
}

// ExchangeRate returns the value of the "exchange_rate" field in the mutation.
func (m *LedgerTransactionMutation) ExchangeRate() (r decimal.Decimal, exists bool) {
	v := m.exchange_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeRate returns the old "exchange_rate" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldExchangeRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeRate: %w", err)
	}
	return oldValue.ExchangeRate, nil
}

// AddExchangeRate adds d to the "exchange_rate" field.
func (m *LedgerTransactionMutation) AddExchangeRate(d decimal.Decimal) {
	if m.addexchange_rate != nil {
		*m.addexchange_rate = m.addexchange_rate.Add(d)
	} else {
		m.addexchange_rate = &d
	}
}

// AddedExchangeRate returns the value that was added to the "exchange_rate" field in this mutation.
func (m *LedgerTransactionMutation) AddedExchangeRate() (r decimal.Decimal, exists bool) {
	v := m.addexchange_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetExchangeRate resets all changes to the "exchange_rate" field.
func (m *LedgerTransactionMutation) ResetExchangeRate() {
	m.exchange_rate = nil
	m.addexchange_rate = nil
}

// SetReferenceType sets the "reference_type" field.
func (m *LedgerTransactionMutation) SetReferenceType(s string) {
	m.reference_type = &s
}

// ReferenceType returns the value of the "reference_type" field in the mutation.
func (m *LedgerTransactionMutation) ReferenceType() (r string, exists bool) {
	v := m.reference_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceType returns the old "reference_type" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldReferenceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceType: %w", err)
	}
	return oldValue.ReferenceType, nil
}

// ClearReferenceType clears the value of the "reference_type" field.
func (m *LedgerTransactionMutation) ClearReferenceType() {
	m.reference_type = nil
	m.clearedFields[ledgertransaction.FieldReferenceType] = struct{}{}
}

// ReferenceTypeCleared returns if the "reference_type" field was cleared in this mutation.
func (m *LedgerTransactionMutation) ReferenceTypeCleared() bool {
	_, ok := m.clearedFields[ledgertransaction.FieldReferenceType]
	return ok
}

// ResetReferenceType resets all changes to the "reference_type" field.
func (m *LedgerTransactionMutation) ResetReferenceType() {
	m.reference_type = nil
	delete(m.clearedFields, ledgertransaction.FieldReferenceType)
}

// SetReferenceID sets the "reference_id" field.
func (m *LedgerTransactionMutation) SetReferenceID(u uuid.UUID) {
	m.reference_id = &u
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *LedgerTransactionMutation) ReferenceID() (r uuid.UUID, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldReferenceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ClearReferenceID clears the value of the "reference_id" field.
func (m *LedgerTransactionMutation) ClearReferenceID() {
	m.reference_id = nil
	m.clearedFields[ledgertransaction.FieldReferenceID] = struct{}{}
}

// ReferenceIDCleared returns if the "reference_id" field was cleared in this mutation.
func (m *LedgerTransactionMutation) ReferenceIDCleared() bool {
	_, ok := m.clearedFields[ledgertransaction.FieldReferenceID]
	return ok
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *LedgerTransactionMutation) ResetReferenceID() {
	m.reference_id = nil
	delete(m.clearedFields, ledgertransaction.FieldReferenceID)
}

// SetTransactionDate sets the "transaction_date" field.
func (m *LedgerTransactionMutation) SetTransactionDate(t time.Time) {
	m.transaction_date = &t
}

// TransactionDate returns the value of the "transaction_date" field in the mutation.
func (m *LedgerTransactionMutation) TransactionDate() (r time.Time, exists bool) {
	v := m.transaction_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionDate returns the old "transaction_date" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldTransactionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionDate: %w", err)
	}
	return oldValue.TransactionDate, nil
}

// ResetTransactionDate resets all changes to the "transaction_date" field.
func (m *LedgerTransactionMutation) ResetTransactionDate() {
	m.transaction_date = nil
}

// SetDescription sets the "description" field.
func (m *LedgerTransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LedgerTransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LedgerTransactionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ledgertransaction.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LedgerTransactionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ledgertransaction.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LedgerTransactionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ledgertransaction.FieldDescription)
}

// SetMetadata sets the "metadata" field.
func (m *LedgerTransactionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LedgerTransactionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LedgerTransactionMutation) ResetMetadata() {
	m.metadata = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LedgerTransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LedgerTransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LedgerTransaction entity.
// If the LedgerTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LedgerTransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LedgerTransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAccount clears the "account" edge to the ChartOfAccount entity.
func (m *LedgerTransactionMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[ledgertransaction.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the ChartOfAccount entity was cleared.
func (m *LedgerTransactionMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *LedgerTransactionMutation) AccountIDs() (ids []uuid.UUID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *LedgerTransactionMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the LedgerTransactionMutation builder.
func (m *LedgerTransactionMutation) Where(ps ...predicate.LedgerTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LedgerTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LedgerTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LedgerTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LedgerTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LedgerTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LedgerTransaction).
func (m *LedgerTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LedgerTransactionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.tenant_id != nil {
		fields = append(fields, ledgertransaction.FieldTenantID)
	}
	if m.account != nil {
		fields = append(fields, ledgertransaction.FieldAccountID)
	}
	if m.journal_entry_id != nil {
		fields = append(fields, ledgertransaction.FieldJournalEntryID)
	}
	if m.debit_amount != nil {
		fields = append(fields, ledgertransaction.FieldDebitAmount)
	}
	if m.credit_amount != nil {
		fields = append(fields, ledgertransaction.FieldCreditAmount)
	}
	if m.currency != nil {
		fields = append(fields, ledgertransaction.FieldCurrency)
	}
	if m.exchange_rate != nil {
		fields = append(fields, ledgertransaction.FieldExchangeRate)
	}
	if m.reference_type != nil {
		fields = append(fields, ledgertransaction.FieldReferenceType)
	}
	if m.reference_id != nil {
		fields = append(fields, ledgertransaction.FieldReferenceID)
	}
	if m.transaction_date != nil {
		fields = append(fields, ledgertransaction.FieldTransactionDate)
	}
	if m.description != nil {
		fields = append(fields, ledgertransaction.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, ledgertransaction.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, ledgertransaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LedgerTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ledgertransaction.FieldTenantID:
		return m.TenantID()
	case ledgertransaction.FieldAccountID:
		return m.AccountID()
	case ledgertransaction.FieldJournalEntryID:
		return m.JournalEntryID()
	case ledgertransaction.FieldDebitAmount:
		return m.DebitAmount()
	case ledgertransaction.FieldCreditAmount:
		return m.CreditAmount()
	case ledgertransaction.FieldCurrency:
		return m.Currency()
	case ledgertransaction.FieldExchangeRate:
		return m.ExchangeRate()
	case ledgertransaction.FieldReferenceType:
		return m.ReferenceType()
	case ledgertransaction.FieldReferenceID:
		return m.ReferenceID()
	case ledgertransaction.FieldTransactionDate:
		return m.TransactionDate()
	case ledgertransaction.FieldDescription:
		return m.Description()
	case ledgertransaction.FieldMetadata:
		return m.Metadata()
	case ledgertransaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LedgerTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ledgertransaction.FieldTenantID:
		return m.OldTenantID(ctx)
	case ledgertransaction.FieldAccountID:
		return m.OldAccountID(ctx)
	case ledgertransaction.FieldJournalEntryID:
		return m.OldJournalEntryID(ctx)
	case ledgertransaction.FieldDebitAmount:
		return m.OldDebitAmount(ctx)
	case ledgertransaction.FieldCreditAmount:
		return m.OldCreditAmount(ctx)
	case ledgertransaction.FieldCurrency:
		return m.OldCurrency(ctx)
	case ledgertransaction.FieldExchangeRate:
		return m.OldExchangeRate(ctx)
	case ledgertransaction.FieldReferenceType:
		return m.OldReferenceType(ctx)
	case ledgertransaction.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case ledgertransaction.FieldTransactionDate:
		return m.OldTransactionDate(ctx)
	case ledgertransaction.FieldDescription:
		return m.OldDescription(ctx)
	case ledgertransaction.FieldMetadata:
		return m.OldMetadata(ctx)
	case ledgertransaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LedgerTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ledgertransaction.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ledgertransaction.FieldAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case ledgertransaction.FieldJournalEntryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJournalEntryID(v)
		return nil
	case ledgertransaction.FieldDebitAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebitAmount(v)
		return nil
	case ledgertransaction.FieldCreditAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAmount(v)
		return nil
	case ledgertransaction.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case ledgertransaction.FieldExchangeRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeRate(v)
		return nil
	case ledgertransaction.FieldReferenceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceType(v)
		return nil
	case ledgertransaction.FieldReferenceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case ledgertransaction.FieldTransactionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionDate(v)
		return nil
	case ledgertransaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ledgertransaction.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case ledgertransaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LedgerTransactionMutation) AddedFields() []string {
	var fields []string
	if m.adddebit_amount != nil {
		fields = append(fields, ledgertransaction.FieldDebitAmount)
	}
	if m.addcredit_amount != nil {
		fields = append(fields, ledgertransaction.FieldCreditAmount)
	}
	if m.addexchange_rate != nil {
		fields = append(fields, ledgertransaction.FieldExchangeRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LedgerTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ledgertransaction.FieldDebitAmount:
		return m.AddedDebitAmount()
	case ledgertransaction.FieldCreditAmount:
		return m.AddedCreditAmount()
	case ledgertransaction.FieldExchangeRate:
		return m.AddedExchangeRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LedgerTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ledgertransaction.FieldDebitAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDebitAmount(v)
		return nil
	case ledgertransaction.FieldCreditAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditAmount(v)
		return nil
	case ledgertransaction.FieldExchangeRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExchangeRate(v)
		return nil
	}
	return fmt.Errorf("unknown LedgerTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LedgerTransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ledgertransaction.FieldJournalEntryID) {
		fields = append(fields, ledgertransaction.FieldJournalEntryID)
	}
	if m.FieldCleared(ledgertransaction.FieldReferenceType) {
		fields = append(fields, ledgertransaction.FieldReferenceType)
	}
	if m.FieldCleared(ledgertransaction.FieldReferenceID) {
		fields = append(fields, ledgertransaction.FieldReferenceID)
	}
	if m.FieldCleared(ledgertransaction.FieldDescription) {
		fields = append(fields, ledgertransaction.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LedgerTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LedgerTransactionMutation) ClearField(name string) error {
	switch name {
	case ledgertransaction.FieldJournalEntryID:
		m.ClearJournalEntryID()
		return nil
	case ledgertransaction.FieldReferenceType:
		m.ClearReferenceType()
		return nil
	case ledgertransaction.FieldReferenceID:
		m.ClearReferenceID()
		return nil
	case ledgertransaction.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown LedgerTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LedgerTransactionMutation) ResetField(name string) error {
	switch name {
	case ledgertransaction.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ledgertransaction.FieldAccountID:
		m.ResetAccountID()
		return nil
	case ledgertransaction.FieldJournalEntryID:
		m.ResetJournalEntryID()
		return nil
	case ledgertransaction.FieldDebitAmount:
		m.ResetDebitAmount()
		return nil
	case ledgertransaction.FieldCreditAmount:
		m.ResetCreditAmount()
		return nil
	case ledgertransaction.FieldCurrency:
		m.ResetCurrency()
		return nil
	case ledgertransaction.FieldExchangeRate:
		m.ResetExchangeRate()
		return nil
	case ledgertransaction.FieldReferenceType:
		m.ResetReferenceType()
		return nil
	case ledgertransaction.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case ledgertransaction.FieldTransactionDate:
		m.ResetTransactionDate()
		return nil
	case ledgertransaction.FieldDescription:
		m.ResetDescription()
		return nil
	case ledgertransaction.FieldMetadata:
		m.ResetMetadata()
		return nil
	case ledgertransaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown LedgerTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LedgerTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, ledgertransaction.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LedgerTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ledgertransaction.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LedgerTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LedgerTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LedgerTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, ledgertransaction.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LedgerTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case ledgertransaction.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LedgerTransactionMutation) ClearEdge(name string) error {
	switch name {
	case ledgertransaction.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown LedgerTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LedgerTransactionMutation) ResetEdge(name string) error {
	switch name {
	case ledgertransaction.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown LedgerTransaction edge %s", name)
}

// OutboxEventMutation represents an operation that mutates the OutboxEvent nodes in the graph.
type OutboxEventMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	tenant_id       *uuid.UUID
	aggregate_type  *string
	aggregate_id    *uuid.UUID
	event_type      *string
	payload         *map[string]interface{}
	status          *string
	attempts        *int
	addattempts     *int
	last_attempt_at *time.Time
	published_at    *time.Time
	error_message   *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*OutboxEvent, error)
	predicates      []predicate.OutboxEvent
}

var _ ent.Mutation = (*OutboxEventMutation)(nil)

// outboxeventOption allows management of the mutation configuration using functional options.
type outboxeventOption func(*OutboxEventMutation)

// newOutboxEventMutation creates new mutation for the OutboxEvent entity.
func newOutboxEventMutation(c config, op Op, opts ...outboxeventOption) *OutboxEventMutation {
	m := &OutboxEventMutation{
		config:        c,
		op:            op,
		typ:           TypeOutboxEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutboxEventID sets the ID field of the mutation.
func withOutboxEventID(id uuid.UUID) outboxeventOption {
	return func(m *OutboxEventMutation) {
		var (
			err   error
			once  sync.Once
			value *OutboxEvent
		)
		m.oldValue = func(ctx context.Context) (*OutboxEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutboxEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutboxEvent sets the old OutboxEvent of the mutation.
func withOutboxEvent(node *OutboxEvent) outboxeventOption {
	return func(m *OutboxEventMutation) {
		m.oldValue = func(context.Context) (*OutboxEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutboxEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutboxEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OutboxEvent entities.
func (m *OutboxEventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutboxEventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutboxEventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutboxEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OutboxEventMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OutboxEventMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OutboxEventMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetAggregateType sets the "aggregate_type" field.
func (m *OutboxEventMutation) SetAggregateType(s string) {
	m.aggregate_type = &s
}

// AggregateType returns the value of the "aggregate_type" field in the mutation.
func (m *OutboxEventMutation) AggregateType() (r string, exists bool) {
	v := m.aggregate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregateType returns the old "aggregate_type" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldAggregateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregateType: %w", err)
	}
	return oldValue.AggregateType, nil
}

// ResetAggregateType resets all changes to the "aggregate_type" field.
func (m *OutboxEventMutation) ResetAggregateType() {
	m.aggregate_type = nil
}

// SetAggregateID sets the "aggregate_id" field.
func (m *OutboxEventMutation) SetAggregateID(u uuid.UUID) {
	m.aggregate_id = &u
}

// AggregateID returns the value of the "aggregate_id" field in the mutation.
func (m *OutboxEventMutation) AggregateID() (r uuid.UUID, exists bool) {
	v := m.aggregate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregateID returns the old "aggregate_id" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldAggregateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregateID: %w", err)
	}
	return oldValue.AggregateID, nil
}

// ResetAggregateID resets all changes to the "aggregate_id" field.
func (m *OutboxEventMutation) ResetAggregateID() {
	m.aggregate_id = nil
}

// SetEventType sets the "event_type" field.
func (m *OutboxEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *OutboxEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *OutboxEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetPayload sets the "payload" field.
func (m *OutboxEventMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *OutboxEventMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *OutboxEventMutation) ResetPayload() {
	m.payload = nil
}

// SetStatus sets the "status" field.
func (m *OutboxEventMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *OutboxEventMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OutboxEventMutation) ResetStatus() {
	m.status = nil
}

// SetAttempts sets the "attempts" field.
func (m *OutboxEventMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *OutboxEventMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *OutboxEventMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *OutboxEventMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *OutboxEventMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetLastAttemptAt sets the "last_attempt_at" field.
func (m *OutboxEventMutation) SetLastAttemptAt(t time.Time) {
	m.last_attempt_at = &t
}

// LastAttemptAt returns the value of the "last_attempt_at" field in the mutation.
func (m *OutboxEventMutation) LastAttemptAt() (r time.Time, exists bool) {
	v := m.last_attempt_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAttemptAt returns the old "last_attempt_at" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldLastAttemptAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAttemptAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAttemptAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAttemptAt: %w", err)
	}
	return oldValue.LastAttemptAt, nil
}

// ClearLastAttemptAt clears the value of the "last_attempt_at" field.
func (m *OutboxEventMutation) ClearLastAttemptAt() {
	m.last_attempt_at = nil
	m.clearedFields[outboxevent.FieldLastAttemptAt] = struct{}{}
}

// LastAttemptAtCleared returns if the "last_attempt_at" field was cleared in this mutation.
func (m *OutboxEventMutation) LastAttemptAtCleared() bool {
	_, ok := m.clearedFields[outboxevent.FieldLastAttemptAt]
	return ok
}

// ResetLastAttemptAt resets all changes to the "last_attempt_at" field.
func (m *OutboxEventMutation) ResetLastAttemptAt() {
	m.last_attempt_at = nil
	delete(m.clearedFields, outboxevent.FieldLastAttemptAt)
}

// SetPublishedAt sets the "published_at" field.
func (m *OutboxEventMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *OutboxEventMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *OutboxEventMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[outboxevent.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *OutboxEventMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[outboxevent.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *OutboxEventMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, outboxevent.FieldPublishedAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *OutboxEventMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *OutboxEventMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *OutboxEventMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[outboxevent.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *OutboxEventMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[outboxevent.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *OutboxEventMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, outboxevent.FieldErrorMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *OutboxEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OutboxEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OutboxEvent entity.
// If the OutboxEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutboxEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OutboxEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the OutboxEventMutation builder.
func (m *OutboxEventMutation) Where(ps ...predicate.OutboxEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OutboxEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OutboxEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OutboxEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OutboxEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OutboxEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OutboxEvent).
func (m *OutboxEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutboxEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.tenant_id != nil {
		fields = append(fields, outboxevent.FieldTenantID)
	}
	if m.aggregate_type != nil {
		fields = append(fields, outboxevent.FieldAggregateType)
	}
	if m.aggregate_id != nil {
		fields = append(fields, outboxevent.FieldAggregateID)
	}
	if m.event_type != nil {
		fields = append(fields, outboxevent.FieldEventType)
	}
	if m.payload != nil {
		fields = append(fields, outboxevent.FieldPayload)
	}
	if m.status != nil {
		fields = append(fields, outboxevent.FieldStatus)
	}
	if m.attempts != nil {
		fields = append(fields, outboxevent.FieldAttempts)
	}
	if m.last_attempt_at != nil {
		fields = append(fields, outboxevent.FieldLastAttemptAt)
	}
	if m.published_at != nil {
		fields = append(fields, outboxevent.FieldPublishedAt)
	}
	if m.error_message != nil {
		fields = append(fields, outboxevent.FieldErrorMessage)
	}
	if m.created_at != nil {
		fields = append(fields, outboxevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutboxEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outboxevent.FieldTenantID:
		return m.TenantID()
	case outboxevent.FieldAggregateType:
		return m.AggregateType()
	case outboxevent.FieldAggregateID:
		return m.AggregateID()
	case outboxevent.FieldEventType:
		return m.EventType()
	case outboxevent.FieldPayload:
		return m.Payload()
	case outboxevent.FieldStatus:
		return m.Status()
	case outboxevent.FieldAttempts:
		return m.Attempts()
	case outboxevent.FieldLastAttemptAt:
		return m.LastAttemptAt()
	case outboxevent.FieldPublishedAt:
		return m.PublishedAt()
	case outboxevent.FieldErrorMessage:
		return m.ErrorMessage()
	case outboxevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutboxEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outboxevent.FieldTenantID:
		return m.OldTenantID(ctx)
	case outboxevent.FieldAggregateType:
		return m.OldAggregateType(ctx)
	case outboxevent.FieldAggregateID:
		return m.OldAggregateID(ctx)
	case outboxevent.FieldEventType:
		return m.OldEventType(ctx)
	case outboxevent.FieldPayload:
		return m.OldPayload(ctx)
	case outboxevent.FieldStatus:
		return m.OldStatus(ctx)
	case outboxevent.FieldAttempts:
		return m.OldAttempts(ctx)
	case outboxevent.FieldLastAttemptAt:
		return m.OldLastAttemptAt(ctx)
	case outboxevent.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case outboxevent.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case outboxevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OutboxEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutboxEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outboxevent.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case outboxevent.FieldAggregateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregateType(v)
		return nil
	case outboxevent.FieldAggregateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregateID(v)
		return nil
	case outboxevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case outboxevent.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case outboxevent.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case outboxevent.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case outboxevent.FieldLastAttemptAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAttemptAt(v)
		return nil
	case outboxevent.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case outboxevent.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case outboxevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OutboxEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutboxEventMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, outboxevent.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutboxEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outboxevent.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutboxEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outboxevent.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown OutboxEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutboxEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(outboxevent.FieldLastAttemptAt) {
		fields = append(fields, outboxevent.FieldLastAttemptAt)
	}
	if m.FieldCleared(outboxevent.FieldPublishedAt) {
		fields = append(fields, outboxevent.FieldPublishedAt)
	}
	if m.FieldCleared(outboxevent.FieldErrorMessage) {
		fields = append(fields, outboxevent.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutboxEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutboxEventMutation) ClearField(name string) error {
	switch name {
	case outboxevent.FieldLastAttemptAt:
		m.ClearLastAttemptAt()
		return nil
	case outboxevent.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case outboxevent.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown OutboxEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutboxEventMutation) ResetField(name string) error {
	switch name {
	case outboxevent.FieldTenantID:
		m.ResetTenantID()
		return nil
	case outboxevent.FieldAggregateType:
		m.ResetAggregateType()
		return nil
	case outboxevent.FieldAggregateID:
		m.ResetAggregateID()
		return nil
	case outboxevent.FieldEventType:
		m.ResetEventType()
		return nil
	case outboxevent.FieldPayload:
		m.ResetPayload()
		return nil
	case outboxevent.FieldStatus:
		m.ResetStatus()
		return nil
	case outboxevent.FieldAttempts:
		m.ResetAttempts()
		return nil
	case outboxevent.FieldLastAttemptAt:
		m.ResetLastAttemptAt()
		return nil
	case outboxevent.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case outboxevent.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case outboxevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OutboxEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutboxEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutboxEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutboxEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutboxEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutboxEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutboxEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutboxEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OutboxEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutboxEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OutboxEvent edge %s", name)
}

// PaymentIntentMutation represents an operation that mutates the PaymentIntent nodes in the graph.
type PaymentIntentMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	tenant_id      *uuid.UUID
	reference_id   *string
	reference_type *string
	payment_method *string
	currency       *string
	amount         *decimal.Decimal
	addamount      *decimal.Decimal
	status         *string
	metadata       *map[string]interface{}
	customer_id    *uuid.UUID
	description    *string
	expires_at     *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*PaymentIntent, error)
	predicates     []predicate.PaymentIntent
}

var _ ent.Mutation = (*PaymentIntentMutation)(nil)

// paymentintentOption allows management of the mutation configuration using functional options.
type paymentintentOption func(*PaymentIntentMutation)

// newPaymentIntentMutation creates new mutation for the PaymentIntent entity.
func newPaymentIntentMutation(c config, op Op, opts ...paymentintentOption) *PaymentIntentMutation {
	m := &PaymentIntentMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentIntent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentIntentID sets the ID field of the mutation.
func withPaymentIntentID(id uuid.UUID) paymentintentOption {
	return func(m *PaymentIntentMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentIntent
		)
		m.oldValue = func(ctx context.Context) (*PaymentIntent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentIntent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentIntent sets the old PaymentIntent of the mutation.
func withPaymentIntent(node *PaymentIntent) paymentintentOption {
	return func(m *PaymentIntentMutation) {
		m.oldValue = func(context.Context) (*PaymentIntent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentIntentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentIntentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentIntent entities.
func (m *PaymentIntentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentIntentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentIntentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentIntent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PaymentIntentMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PaymentIntentMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PaymentIntentMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *PaymentIntentMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *PaymentIntentMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *PaymentIntentMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetReferenceType sets the "reference_type" field.
func (m *PaymentIntentMutation) SetReferenceType(s string) {
	m.reference_type = &s
}

// ReferenceType returns the value of the "reference_type" field in the mutation.
func (m *PaymentIntentMutation) ReferenceType() (r string, exists bool) {
	v := m.reference_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceType returns the old "reference_type" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldReferenceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceType: %w", err)
	}
	return oldValue.ReferenceType, nil
}

// ResetReferenceType resets all changes to the "reference_type" field.
func (m *PaymentIntentMutation) ResetReferenceType() {
	m.reference_type = nil
}

// SetPaymentMethod sets the "payment_method" field.
func (m *PaymentIntentMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *PaymentIntentMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldPaymentMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *PaymentIntentMutation) ResetPaymentMethod() {
	m.payment_method = nil
}

// SetCurrency sets the "currency" field.
func (m *PaymentIntentMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PaymentIntentMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PaymentIntentMutation) ResetCurrency() {
	m.currency = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentIntentMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentIntentMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *PaymentIntentMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentIntentMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentIntentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *PaymentIntentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentIntentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentIntentMutation) ResetStatus() {
	m.status = nil
}

// SetMetadata sets the "metadata" field.
func (m *PaymentIntentMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PaymentIntentMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PaymentIntentMutation) ResetMetadata() {
	m.metadata = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *PaymentIntentMutation) SetCustomerID(u uuid.UUID) {
	m.customer_id = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *PaymentIntentMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *PaymentIntentMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[paymentintent.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *PaymentIntentMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[paymentintent.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *PaymentIntentMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, paymentintent.FieldCustomerID)
}

// SetDescription sets the "description" field.
func (m *PaymentIntentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PaymentIntentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PaymentIntentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[paymentintent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PaymentIntentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[paymentintent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PaymentIntentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, paymentintent.FieldDescription)
}

// SetExpiresAt sets the "expires_at" field.
func (m *PaymentIntentMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PaymentIntentMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *PaymentIntentMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[paymentintent.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *PaymentIntentMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[paymentintent.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PaymentIntentMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, paymentintent.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentIntentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentIntentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentIntentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentIntentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentIntentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentIntentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the PaymentIntentMutation builder.
func (m *PaymentIntentMutation) Where(ps ...predicate.PaymentIntent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentIntentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentIntentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentIntent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentIntentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentIntentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentIntent).
func (m *PaymentIntentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentIntentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.tenant_id != nil {
		fields = append(fields, paymentintent.FieldTenantID)
	}
	if m.reference_id != nil {
		fields = append(fields, paymentintent.FieldReferenceID)
	}
	if m.reference_type != nil {
		fields = append(fields, paymentintent.FieldReferenceType)
	}
	if m.payment_method != nil {
		fields = append(fields, paymentintent.FieldPaymentMethod)
	}
	if m.currency != nil {
		fields = append(fields, paymentintent.FieldCurrency)
	}
	if m.amount != nil {
		fields = append(fields, paymentintent.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, paymentintent.FieldStatus)
	}
	if m.metadata != nil {
		fields = append(fields, paymentintent.FieldMetadata)
	}
	if m.customer_id != nil {
		fields = append(fields, paymentintent.FieldCustomerID)
	}
	if m.description != nil {
		fields = append(fields, paymentintent.FieldDescription)
	}
	if m.expires_at != nil {
		fields = append(fields, paymentintent.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, paymentintent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymentintent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentIntentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentintent.FieldTenantID:
		return m.TenantID()
	case paymentintent.FieldReferenceID:
		return m.ReferenceID()
	case paymentintent.FieldReferenceType:
		return m.ReferenceType()
	case paymentintent.FieldPaymentMethod:
		return m.PaymentMethod()
	case paymentintent.FieldCurrency:
		return m.Currency()
	case paymentintent.FieldAmount:
		return m.Amount()
	case paymentintent.FieldStatus:
		return m.Status()
	case paymentintent.FieldMetadata:
		return m.Metadata()
	case paymentintent.FieldCustomerID:
		return m.CustomerID()
	case paymentintent.FieldDescription:
		return m.Description()
	case paymentintent.FieldExpiresAt:
		return m.ExpiresAt()
	case paymentintent.FieldCreatedAt:
		return m.CreatedAt()
	case paymentintent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentIntentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentintent.FieldTenantID:
		return m.OldTenantID(ctx)
	case paymentintent.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case paymentintent.FieldReferenceType:
		return m.OldReferenceType(ctx)
	case paymentintent.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case paymentintent.FieldCurrency:
		return m.OldCurrency(ctx)
	case paymentintent.FieldAmount:
		return m.OldAmount(ctx)
	case paymentintent.FieldStatus:
		return m.OldStatus(ctx)
	case paymentintent.FieldMetadata:
		return m.OldMetadata(ctx)
	case paymentintent.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case paymentintent.FieldDescription:
		return m.OldDescription(ctx)
	case paymentintent.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case paymentintent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentintent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentIntent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentIntentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentintent.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case paymentintent.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case paymentintent.FieldReferenceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceType(v)
		return nil
	case paymentintent.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case paymentintent.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case paymentintent.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymentintent.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case paymentintent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case paymentintent.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case paymentintent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case paymentintent.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case paymentintent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentintent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentIntent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentIntentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, paymentintent.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentIntentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentintent.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentIntentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentintent.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentIntent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentIntentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentintent.FieldCustomerID) {
		fields = append(fields, paymentintent.FieldCustomerID)
	}
	if m.FieldCleared(paymentintent.FieldDescription) {
		fields = append(fields, paymentintent.FieldDescription)
	}
	if m.FieldCleared(paymentintent.FieldExpiresAt) {
		fields = append(fields, paymentintent.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentIntentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentIntentMutation) ClearField(name string) error {
	switch name {
	case paymentintent.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case paymentintent.FieldDescription:
		m.ClearDescription()
		return nil
	case paymentintent.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentIntent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentIntentMutation) ResetField(name string) error {
	switch name {
	case paymentintent.FieldTenantID:
		m.ResetTenantID()
		return nil
	case paymentintent.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case paymentintent.FieldReferenceType:
		m.ResetReferenceType()
		return nil
	case paymentintent.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case paymentintent.FieldCurrency:
		m.ResetCurrency()
		return nil
	case paymentintent.FieldAmount:
		m.ResetAmount()
		return nil
	case paymentintent.FieldStatus:
		m.ResetStatus()
		return nil
	case paymentintent.FieldMetadata:
		m.ResetMetadata()
		return nil
	case paymentintent.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case paymentintent.FieldDescription:
		m.ResetDescription()
		return nil
	case paymentintent.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case paymentintent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentintent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentIntent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentIntentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentIntentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentIntentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentIntentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentIntentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentIntentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentIntentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentIntent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentIntentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentIntent edge %s", name)
}

// PaymentTransactionMutation represents an operation that mutates the PaymentTransaction nodes in the graph.
type PaymentTransactionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	tenant_id          *uuid.UUID
	payment_intent_id  *uuid.UUID
	transaction_type   *string
	amount             *decimal.Decimal
	addamount          *decimal.Decimal
	currency           *string
	provider           *string
	provider_reference *string
	status             *string
	processed_at       *time.Time
	metadata           *map[string]interface{}
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*PaymentTransaction, error)
	predicates         []predicate.PaymentTransaction
}

var _ ent.Mutation = (*PaymentTransactionMutation)(nil)

// paymenttransactionOption allows management of the mutation configuration using functional options.
type paymenttransactionOption func(*PaymentTransactionMutation)

// newPaymentTransactionMutation creates new mutation for the PaymentTransaction entity.
func newPaymentTransactionMutation(c config, op Op, opts ...paymenttransactionOption) *PaymentTransactionMutation {
	m := &PaymentTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentTransactionID sets the ID field of the mutation.
func withPaymentTransactionID(id uuid.UUID) paymenttransactionOption {
	return func(m *PaymentTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentTransaction
		)
		m.oldValue = func(ctx context.Context) (*PaymentTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentTransaction sets the old PaymentTransaction of the mutation.
func withPaymentTransaction(node *PaymentTransaction) paymenttransactionOption {
	return func(m *PaymentTransactionMutation) {
		m.oldValue = func(context.Context) (*PaymentTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentTransaction entities.
func (m *PaymentTransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentTransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentTransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PaymentTransactionMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PaymentTransactionMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PaymentTransactionMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetPaymentIntentID sets the "payment_intent_id" field.
func (m *PaymentTransactionMutation) SetPaymentIntentID(u uuid.UUID) {
	m.payment_intent_id = &u
}

// PaymentIntentID returns the value of the "payment_intent_id" field in the mutation.
func (m *PaymentTransactionMutation) PaymentIntentID() (r uuid.UUID, exists bool) {
	v := m.payment_intent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentIntentID returns the old "payment_intent_id" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldPaymentIntentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentIntentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentIntentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentIntentID: %w", err)
	}
	return oldValue.PaymentIntentID, nil
}

// ResetPaymentIntentID resets all changes to the "payment_intent_id" field.
func (m *PaymentTransactionMutation) ResetPaymentIntentID() {
	m.payment_intent_id = nil
}

// SetTransactionType sets the "transaction_type" field.
func (m *PaymentTransactionMutation) SetTransactionType(s string) {
	m.transaction_type = &s
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *PaymentTransactionMutation) TransactionType() (r string, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldTransactionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *PaymentTransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentTransactionMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentTransactionMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *PaymentTransactionMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentTransactionMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentTransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *PaymentTransactionMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PaymentTransactionMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PaymentTransactionMutation) ResetCurrency() {
	m.currency = nil
}

// SetProvider sets the "provider" field.
func (m *PaymentTransactionMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *PaymentTransactionMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *PaymentTransactionMutation) ResetProvider() {
	m.provider = nil
}

// SetProviderReference sets the "provider_reference" field.
func (m *PaymentTransactionMutation) SetProviderReference(s string) {
	m.provider_reference = &s
}

// ProviderReference returns the value of the "provider_reference" field in the mutation.
func (m *PaymentTransactionMutation) ProviderReference() (r string, exists bool) {
	v := m.provider_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderReference returns the old "provider_reference" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldProviderReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderReference: %w", err)
	}
	return oldValue.ProviderReference, nil
}

// ResetProviderReference resets all changes to the "provider_reference" field.
func (m *PaymentTransactionMutation) ResetProviderReference() {
	m.provider_reference = nil
}

// SetStatus sets the "status" field.
func (m *PaymentTransactionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentTransactionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentTransactionMutation) ResetStatus() {
	m.status = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *PaymentTransactionMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *PaymentTransactionMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldProcessedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *PaymentTransactionMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[paymenttransaction.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *PaymentTransactionMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[paymenttransaction.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *PaymentTransactionMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, paymenttransaction.FieldProcessedAt)
}

// SetMetadata sets the "metadata" field.
func (m *PaymentTransactionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *PaymentTransactionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *PaymentTransactionMutation) ResetMetadata() {
	m.metadata = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentTransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentTransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentTransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentTransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentTransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PaymentTransaction entity.
// If the PaymentTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentTransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentTransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the PaymentTransactionMutation builder.
func (m *PaymentTransactionMutation) Where(ps ...predicate.PaymentTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentTransaction).
func (m *PaymentTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentTransactionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.tenant_id != nil {
		fields = append(fields, paymenttransaction.FieldTenantID)
	}
	if m.payment_intent_id != nil {
		fields = append(fields, paymenttransaction.FieldPaymentIntentID)
	}
	if m.transaction_type != nil {
		fields = append(fields, paymenttransaction.FieldTransactionType)
	}
	if m.amount != nil {
		fields = append(fields, paymenttransaction.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, paymenttransaction.FieldCurrency)
	}
	if m.provider != nil {
		fields = append(fields, paymenttransaction.FieldProvider)
	}
	if m.provider_reference != nil {
		fields = append(fields, paymenttransaction.FieldProviderReference)
	}
	if m.status != nil {
		fields = append(fields, paymenttransaction.FieldStatus)
	}
	if m.processed_at != nil {
		fields = append(fields, paymenttransaction.FieldProcessedAt)
	}
	if m.metadata != nil {
		fields = append(fields, paymenttransaction.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, paymenttransaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, paymenttransaction.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymenttransaction.FieldTenantID:
		return m.TenantID()
	case paymenttransaction.FieldPaymentIntentID:
		return m.PaymentIntentID()
	case paymenttransaction.FieldTransactionType:
		return m.TransactionType()
	case paymenttransaction.FieldAmount:
		return m.Amount()
	case paymenttransaction.FieldCurrency:
		return m.Currency()
	case paymenttransaction.FieldProvider:
		return m.Provider()
	case paymenttransaction.FieldProviderReference:
		return m.ProviderReference()
	case paymenttransaction.FieldStatus:
		return m.Status()
	case paymenttransaction.FieldProcessedAt:
		return m.ProcessedAt()
	case paymenttransaction.FieldMetadata:
		return m.Metadata()
	case paymenttransaction.FieldCreatedAt:
		return m.CreatedAt()
	case paymenttransaction.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymenttransaction.FieldTenantID:
		return m.OldTenantID(ctx)
	case paymenttransaction.FieldPaymentIntentID:
		return m.OldPaymentIntentID(ctx)
	case paymenttransaction.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case paymenttransaction.FieldAmount:
		return m.OldAmount(ctx)
	case paymenttransaction.FieldCurrency:
		return m.OldCurrency(ctx)
	case paymenttransaction.FieldProvider:
		return m.OldProvider(ctx)
	case paymenttransaction.FieldProviderReference:
		return m.OldProviderReference(ctx)
	case paymenttransaction.FieldStatus:
		return m.OldStatus(ctx)
	case paymenttransaction.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	case paymenttransaction.FieldMetadata:
		return m.OldMetadata(ctx)
	case paymenttransaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymenttransaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymenttransaction.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case paymenttransaction.FieldPaymentIntentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentIntentID(v)
		return nil
	case paymenttransaction.FieldTransactionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case paymenttransaction.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymenttransaction.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case paymenttransaction.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case paymenttransaction.FieldProviderReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderReference(v)
		return nil
	case paymenttransaction.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case paymenttransaction.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	case paymenttransaction.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case paymenttransaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymenttransaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentTransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, paymenttransaction.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymenttransaction.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymenttransaction.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentTransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymenttransaction.FieldProcessedAt) {
		fields = append(fields, paymenttransaction.FieldProcessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentTransactionMutation) ClearField(name string) error {
	switch name {
	case paymenttransaction.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentTransactionMutation) ResetField(name string) error {
	switch name {
	case paymenttransaction.FieldTenantID:
		m.ResetTenantID()
		return nil
	case paymenttransaction.FieldPaymentIntentID:
		m.ResetPaymentIntentID()
		return nil
	case paymenttransaction.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case paymenttransaction.FieldAmount:
		m.ResetAmount()
		return nil
	case paymenttransaction.FieldCurrency:
		m.ResetCurrency()
		return nil
	case paymenttransaction.FieldProvider:
		m.ResetProvider()
		return nil
	case paymenttransaction.FieldProviderReference:
		m.ResetProviderReference()
		return nil
	case paymenttransaction.FieldStatus:
		m.ResetStatus()
		return nil
	case paymenttransaction.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	case paymenttransaction.FieldMetadata:
		m.ResetMetadata()
		return nil
	case paymenttransaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymenttransaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentTransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentTransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentTransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentTransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentTransaction edge %s", name)
}

// RolePermissionMutation represents an operation that mutates the RolePermission nodes in the graph.
type RolePermissionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	clearedFields     map[string]struct{}
	role              *uuid.UUID
	clearedrole       bool
	permission        *uuid.UUID
	clearedpermission bool
	done              bool
	oldValue          func(context.Context) (*RolePermission, error)
	predicates        []predicate.RolePermission
}

var _ ent.Mutation = (*RolePermissionMutation)(nil)

// rolepermissionOption allows management of the mutation configuration using functional options.
type rolepermissionOption func(*RolePermissionMutation)

// newRolePermissionMutation creates new mutation for the RolePermission entity.
func newRolePermissionMutation(c config, op Op, opts ...rolepermissionOption) *RolePermissionMutation {
	m := &RolePermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeRolePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRolePermissionID sets the ID field of the mutation.
func withRolePermissionID(id int) rolepermissionOption {
	return func(m *RolePermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *RolePermission
		)
		m.oldValue = func(ctx context.Context) (*RolePermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RolePermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRolePermission sets the old RolePermission of the mutation.
func withRolePermission(node *RolePermission) rolepermissionOption {
	return func(m *RolePermissionMutation) {
		m.oldValue = func(context.Context) (*RolePermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RolePermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RolePermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RolePermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RolePermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RolePermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *RolePermissionMutation) SetRoleID(u uuid.UUID) {
	m.role = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RolePermissionMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RolePermissionMutation) ResetRoleID() {
	m.role = nil
}

// SetPermissionID sets the "permission_id" field.
func (m *RolePermissionMutation) SetPermissionID(u uuid.UUID) {
	m.permission = &u
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *RolePermissionMutation) PermissionID() (r uuid.UUID, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldPermissionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *RolePermissionMutation) ResetPermissionID() {
	m.permission = nil
}

// ClearRole clears the "role" edge to the TreasuryRole entity.
func (m *RolePermissionMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[rolepermission.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the TreasuryRole entity was cleared.
func (m *RolePermissionMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RolePermissionMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RolePermissionMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// ClearPermission clears the "permission" edge to the TreasuryPermission entity.
func (m *RolePermissionMutation) ClearPermission() {
	m.clearedpermission = true
	m.clearedFields[rolepermission.FieldPermissionID] = struct{}{}
}

// PermissionCleared reports if the "permission" edge to the TreasuryPermission entity was cleared.
func (m *RolePermissionMutation) PermissionCleared() bool {
	return m.clearedpermission
}

// PermissionIDs returns the "permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionID instead. It exists only for internal usage by the builders.
func (m *RolePermissionMutation) PermissionIDs() (ids []uuid.UUID) {
	if id := m.permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermission resets all changes to the "permission" edge.
func (m *RolePermissionMutation) ResetPermission() {
	m.permission = nil
	m.clearedpermission = false
}

// Where appends a list predicates to the RolePermissionMutation builder.
func (m *RolePermissionMutation) Where(ps ...predicate.RolePermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RolePermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RolePermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RolePermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RolePermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RolePermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RolePermission).
func (m *RolePermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RolePermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, rolepermission.FieldRoleID)
	}
	if m.permission != nil {
		fields = append(fields, rolepermission.FieldPermissionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RolePermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolepermission.FieldRoleID:
		return m.RoleID()
	case rolepermission.FieldPermissionID:
		return m.PermissionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RolePermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolepermission.FieldRoleID:
		return m.OldRoleID(ctx)
	case rolepermission.FieldPermissionID:
		return m.OldPermissionID(ctx)
	}
	return nil, fmt.Errorf("unknown RolePermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolepermission.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case rolepermission.FieldPermissionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RolePermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RolePermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RolePermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RolePermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RolePermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RolePermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RolePermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RolePermissionMutation) ResetField(name string) error {
	switch name {
	case rolepermission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case rolepermission.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RolePermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role != nil {
		edges = append(edges, rolepermission.EdgeRole)
	}
	if m.permission != nil {
		edges = append(edges, rolepermission.EdgePermission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RolePermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolepermission.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case rolepermission.EdgePermission:
		if id := m.permission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RolePermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RolePermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RolePermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole {
		edges = append(edges, rolepermission.EdgeRole)
	}
	if m.clearedpermission {
		edges = append(edges, rolepermission.EdgePermission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RolePermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case rolepermission.EdgeRole:
		return m.clearedrole
	case rolepermission.EdgePermission:
		return m.clearedpermission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RolePermissionMutation) ClearEdge(name string) error {
	switch name {
	case rolepermission.EdgeRole:
		m.ClearRole()
		return nil
	case rolepermission.EdgePermission:
		m.ClearPermission()
		return nil
	}
	return fmt.Errorf("unknown RolePermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RolePermissionMutation) ResetEdge(name string) error {
	switch name {
	case rolepermission.EdgeRole:
		m.ResetRole()
		return nil
	case rolepermission.EdgePermission:
		m.ResetPermission()
		return nil
	}
	return fmt.Errorf("unknown RolePermission edge %s", name)
}

// TreasuryPermissionMutation represents an operation that mutates the TreasuryPermission nodes in the graph.
type TreasuryPermissionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	permission_code         *string
	name                    *string
	module                  *string
	action                  *string
	resource                *string
	description             *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	roles                   map[uuid.UUID]struct{}
	removedroles            map[uuid.UUID]struct{}
	clearedroles            bool
	role_permissions        map[int]struct{}
	removedrole_permissions map[int]struct{}
	clearedrole_permissions bool
	done                    bool
	oldValue                func(context.Context) (*TreasuryPermission, error)
	predicates              []predicate.TreasuryPermission
}

var _ ent.Mutation = (*TreasuryPermissionMutation)(nil)

// treasurypermissionOption allows management of the mutation configuration using functional options.
type treasurypermissionOption func(*TreasuryPermissionMutation)

// newTreasuryPermissionMutation creates new mutation for the TreasuryPermission entity.
func newTreasuryPermissionMutation(c config, op Op, opts ...treasurypermissionOption) *TreasuryPermissionMutation {
	m := &TreasuryPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeTreasuryPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreasuryPermissionID sets the ID field of the mutation.
func withTreasuryPermissionID(id uuid.UUID) treasurypermissionOption {
	return func(m *TreasuryPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *TreasuryPermission
		)
		m.oldValue = func(ctx context.Context) (*TreasuryPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreasuryPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreasuryPermission sets the old TreasuryPermission of the mutation.
func withTreasuryPermission(node *TreasuryPermission) treasurypermissionOption {
	return func(m *TreasuryPermissionMutation) {
		m.oldValue = func(context.Context) (*TreasuryPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreasuryPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreasuryPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TreasuryPermission entities.
func (m *TreasuryPermissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreasuryPermissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreasuryPermissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TreasuryPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPermissionCode sets the "permission_code" field.
func (m *TreasuryPermissionMutation) SetPermissionCode(s string) {
	m.permission_code = &s
}

// PermissionCode returns the value of the "permission_code" field in the mutation.
func (m *TreasuryPermissionMutation) PermissionCode() (r string, exists bool) {
	v := m.permission_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionCode returns the old "permission_code" field's value of the TreasuryPermission entity.
// If the TreasuryPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryPermissionMutation) OldPermissionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionCode: %w", err)
	}
	return oldValue.PermissionCode, nil
}

// ResetPermissionCode resets all changes to the "permission_code" field.
func (m *TreasuryPermissionMutation) ResetPermissionCode() {
	m.permission_code = nil
}

// SetName sets the "name" field.
func (m *TreasuryPermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TreasuryPermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TreasuryPermission entity.
// If the TreasuryPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryPermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TreasuryPermissionMutation) ResetName() {
	m.name = nil
}

// SetModule sets the "module" field.
func (m *TreasuryPermissionMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *TreasuryPermissionMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the TreasuryPermission entity.
// If the TreasuryPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryPermissionMutation) OldModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *TreasuryPermissionMutation) ResetModule() {
	m.module = nil
}

// SetAction sets the "action" field.
func (m *TreasuryPermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *TreasuryPermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the TreasuryPermission entity.
// If the TreasuryPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryPermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *TreasuryPermissionMutation) ResetAction() {
	m.action = nil
}

// SetResource sets the "resource" field.
func (m *TreasuryPermissionMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *TreasuryPermissionMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the TreasuryPermission entity.
// If the TreasuryPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryPermissionMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ClearResource clears the value of the "resource" field.
func (m *TreasuryPermissionMutation) ClearResource() {
	m.resource = nil
	m.clearedFields[treasurypermission.FieldResource] = struct{}{}
}

// ResourceCleared returns if the "resource" field was cleared in this mutation.
func (m *TreasuryPermissionMutation) ResourceCleared() bool {
	_, ok := m.clearedFields[treasurypermission.FieldResource]
	return ok
}

// ResetResource resets all changes to the "resource" field.
func (m *TreasuryPermissionMutation) ResetResource() {
	m.resource = nil
	delete(m.clearedFields, treasurypermission.FieldResource)
}

// SetDescription sets the "description" field.
func (m *TreasuryPermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TreasuryPermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TreasuryPermission entity.
// If the TreasuryPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryPermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TreasuryPermissionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[treasurypermission.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TreasuryPermissionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[treasurypermission.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TreasuryPermissionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, treasurypermission.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *TreasuryPermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TreasuryPermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TreasuryPermission entity.
// If the TreasuryPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryPermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TreasuryPermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddRoleIDs adds the "roles" edge to the TreasuryRole entity by ids.
func (m *TreasuryPermissionMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the TreasuryRole entity.
func (m *TreasuryPermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the TreasuryRole entity was cleared.
func (m *TreasuryPermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the TreasuryRole entity by IDs.
func (m *TreasuryPermissionMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the TreasuryRole entity.
func (m *TreasuryPermissionMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *TreasuryPermissionMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *TreasuryPermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddRolePermissionIDs adds the "role_permissions" edge to the RolePermission entity by ids.
func (m *TreasuryPermissionMutation) AddRolePermissionIDs(ids ...int) {
	if m.role_permissions == nil {
		m.role_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.role_permissions[ids[i]] = struct{}{}
	}
}

// ClearRolePermissions clears the "role_permissions" edge to the RolePermission entity.
func (m *TreasuryPermissionMutation) ClearRolePermissions() {
	m.clearedrole_permissions = true
}

// RolePermissionsCleared reports if the "role_permissions" edge to the RolePermission entity was cleared.
func (m *TreasuryPermissionMutation) RolePermissionsCleared() bool {
	return m.clearedrole_permissions
}

// RemoveRolePermissionIDs removes the "role_permissions" edge to the RolePermission entity by IDs.
func (m *TreasuryPermissionMutation) RemoveRolePermissionIDs(ids ...int) {
	if m.removedrole_permissions == nil {
		m.removedrole_permissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_permissions, ids[i])
		m.removedrole_permissions[ids[i]] = struct{}{}
	}
}

// RemovedRolePermissions returns the removed IDs of the "role_permissions" edge to the RolePermission entity.
func (m *TreasuryPermissionMutation) RemovedRolePermissionsIDs() (ids []int) {
	for id := range m.removedrole_permissions {
		ids = append(ids, id)
	}
	return
}

// RolePermissionsIDs returns the "role_permissions" edge IDs in the mutation.
func (m *TreasuryPermissionMutation) RolePermissionsIDs() (ids []int) {
	for id := range m.role_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetRolePermissions resets all changes to the "role_permissions" edge.
func (m *TreasuryPermissionMutation) ResetRolePermissions() {
	m.role_permissions = nil
	m.clearedrole_permissions = false
	m.removedrole_permissions = nil
}

// Where appends a list predicates to the TreasuryPermissionMutation builder.
func (m *TreasuryPermissionMutation) Where(ps ...predicate.TreasuryPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreasuryPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreasuryPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TreasuryPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreasuryPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreasuryPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TreasuryPermission).
func (m *TreasuryPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreasuryPermissionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.permission_code != nil {
		fields = append(fields, treasurypermission.FieldPermissionCode)
	}
	if m.name != nil {
		fields = append(fields, treasurypermission.FieldName)
	}
	if m.module != nil {
		fields = append(fields, treasurypermission.FieldModule)
	}
	if m.action != nil {
		fields = append(fields, treasurypermission.FieldAction)
	}
	if m.resource != nil {
		fields = append(fields, treasurypermission.FieldResource)
	}
	if m.description != nil {
		fields = append(fields, treasurypermission.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, treasurypermission.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreasuryPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treasurypermission.FieldPermissionCode:
		return m.PermissionCode()
	case treasurypermission.FieldName:
		return m.Name()
	case treasurypermission.FieldModule:
		return m.Module()
	case treasurypermission.FieldAction:
		return m.Action()
	case treasurypermission.FieldResource:
		return m.Resource()
	case treasurypermission.FieldDescription:
		return m.Description()
	case treasurypermission.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreasuryPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treasurypermission.FieldPermissionCode:
		return m.OldPermissionCode(ctx)
	case treasurypermission.FieldName:
		return m.OldName(ctx)
	case treasurypermission.FieldModule:
		return m.OldModule(ctx)
	case treasurypermission.FieldAction:
		return m.OldAction(ctx)
	case treasurypermission.FieldResource:
		return m.OldResource(ctx)
	case treasurypermission.FieldDescription:
		return m.OldDescription(ctx)
	case treasurypermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TreasuryPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treasurypermission.FieldPermissionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionCode(v)
		return nil
	case treasurypermission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case treasurypermission.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case treasurypermission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case treasurypermission.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case treasurypermission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case treasurypermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TreasuryPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreasuryPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreasuryPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreasuryPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreasuryPermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treasurypermission.FieldResource) {
		fields = append(fields, treasurypermission.FieldResource)
	}
	if m.FieldCleared(treasurypermission.FieldDescription) {
		fields = append(fields, treasurypermission.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreasuryPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreasuryPermissionMutation) ClearField(name string) error {
	switch name {
	case treasurypermission.FieldResource:
		m.ClearResource()
		return nil
	case treasurypermission.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown TreasuryPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreasuryPermissionMutation) ResetField(name string) error {
	switch name {
	case treasurypermission.FieldPermissionCode:
		m.ResetPermissionCode()
		return nil
	case treasurypermission.FieldName:
		m.ResetName()
		return nil
	case treasurypermission.FieldModule:
		m.ResetModule()
		return nil
	case treasurypermission.FieldAction:
		m.ResetAction()
		return nil
	case treasurypermission.FieldResource:
		m.ResetResource()
		return nil
	case treasurypermission.FieldDescription:
		m.ResetDescription()
		return nil
	case treasurypermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown TreasuryPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreasuryPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.roles != nil {
		edges = append(edges, treasurypermission.EdgeRoles)
	}
	if m.role_permissions != nil {
		edges = append(edges, treasurypermission.EdgeRolePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreasuryPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treasurypermission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case treasurypermission.EdgeRolePermissions:
		ids := make([]ent.Value, 0, len(m.role_permissions))
		for id := range m.role_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreasuryPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedroles != nil {
		edges = append(edges, treasurypermission.EdgeRoles)
	}
	if m.removedrole_permissions != nil {
		edges = append(edges, treasurypermission.EdgeRolePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreasuryPermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treasurypermission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case treasurypermission.EdgeRolePermissions:
		ids := make([]ent.Value, 0, len(m.removedrole_permissions))
		for id := range m.removedrole_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreasuryPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroles {
		edges = append(edges, treasurypermission.EdgeRoles)
	}
	if m.clearedrole_permissions {
		edges = append(edges, treasurypermission.EdgeRolePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreasuryPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case treasurypermission.EdgeRoles:
		return m.clearedroles
	case treasurypermission.EdgeRolePermissions:
		return m.clearedrole_permissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreasuryPermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TreasuryPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreasuryPermissionMutation) ResetEdge(name string) error {
	switch name {
	case treasurypermission.EdgeRoles:
		m.ResetRoles()
		return nil
	case treasurypermission.EdgeRolePermissions:
		m.ResetRolePermissions()
		return nil
	}
	return fmt.Errorf("unknown TreasuryPermission edge %s", name)
}

// TreasuryRoleMutation represents an operation that mutates the TreasuryRole nodes in the graph.
type TreasuryRoleMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	tenant_id               *uuid.UUID
	role_code               *string
	name                    *string
	description             *string
	is_system_role          *bool
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	permissions             map[uuid.UUID]struct{}
	removedpermissions      map[uuid.UUID]struct{}
	clearedpermissions      bool
	user_assignments        map[uuid.UUID]struct{}
	removeduser_assignments map[uuid.UUID]struct{}
	cleareduser_assignments bool
	role_permissions        map[int]struct{}
	removedrole_permissions map[int]struct{}
	clearedrole_permissions bool
	done                    bool
	oldValue                func(context.Context) (*TreasuryRole, error)
	predicates              []predicate.TreasuryRole
}

var _ ent.Mutation = (*TreasuryRoleMutation)(nil)

// treasuryroleOption allows management of the mutation configuration using functional options.
type treasuryroleOption func(*TreasuryRoleMutation)

// newTreasuryRoleMutation creates new mutation for the TreasuryRole entity.
func newTreasuryRoleMutation(c config, op Op, opts ...treasuryroleOption) *TreasuryRoleMutation {
	m := &TreasuryRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeTreasuryRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreasuryRoleID sets the ID field of the mutation.
func withTreasuryRoleID(id uuid.UUID) treasuryroleOption {
	return func(m *TreasuryRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *TreasuryRole
		)
		m.oldValue = func(ctx context.Context) (*TreasuryRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreasuryRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreasuryRole sets the old TreasuryRole of the mutation.
func withTreasuryRole(node *TreasuryRole) treasuryroleOption {
	return func(m *TreasuryRoleMutation) {
		m.oldValue = func(context.Context) (*TreasuryRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreasuryRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreasuryRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TreasuryRole entities.
func (m *TreasuryRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreasuryRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreasuryRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TreasuryRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TreasuryRoleMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TreasuryRoleMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TreasuryRole entity.
// If the TreasuryRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryRoleMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TreasuryRoleMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetRoleCode sets the "role_code" field.
func (m *TreasuryRoleMutation) SetRoleCode(s string) {
	m.role_code = &s
}

// RoleCode returns the value of the "role_code" field in the mutation.
func (m *TreasuryRoleMutation) RoleCode() (r string, exists bool) {
	v := m.role_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleCode returns the old "role_code" field's value of the TreasuryRole entity.
// If the TreasuryRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryRoleMutation) OldRoleCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleCode: %w", err)
	}
	return oldValue.RoleCode, nil
}

// ResetRoleCode resets all changes to the "role_code" field.
func (m *TreasuryRoleMutation) ResetRoleCode() {
	m.role_code = nil
}

// SetName sets the "name" field.
func (m *TreasuryRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TreasuryRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TreasuryRole entity.
// If the TreasuryRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TreasuryRoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TreasuryRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TreasuryRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TreasuryRole entity.
// If the TreasuryRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryRoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TreasuryRoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[treasuryrole.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TreasuryRoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[treasuryrole.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TreasuryRoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, treasuryrole.FieldDescription)
}

// SetIsSystemRole sets the "is_system_role" field.
func (m *TreasuryRoleMutation) SetIsSystemRole(b bool) {
	m.is_system_role = &b
}

// IsSystemRole returns the value of the "is_system_role" field in the mutation.
func (m *TreasuryRoleMutation) IsSystemRole() (r bool, exists bool) {
	v := m.is_system_role
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSystemRole returns the old "is_system_role" field's value of the TreasuryRole entity.
// If the TreasuryRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryRoleMutation) OldIsSystemRole(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSystemRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSystemRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSystemRole: %w", err)
	}
	return oldValue.IsSystemRole, nil
}

// ResetIsSystemRole resets all changes to the "is_system_role" field.
func (m *TreasuryRoleMutation) ResetIsSystemRole() {
	m.is_system_role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TreasuryRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TreasuryRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TreasuryRole entity.
// If the TreasuryRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TreasuryRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TreasuryRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TreasuryRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TreasuryRole entity.
// If the TreasuryRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TreasuryRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPermissionIDs adds the "permissions" edge to the TreasuryPermission entity by ids.
func (m *TreasuryRoleMutation) AddPermissionIDs(ids ...uuid.UUID) {
	if m.permissions == nil {
		m.permissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the TreasuryPermission entity.
func (m *TreasuryRoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the TreasuryPermission entity was cleared.
func (m *TreasuryRoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the TreasuryPermission entity by IDs.
func (m *TreasuryRoleMutation) RemovePermissionIDs(ids ...uuid.UUID) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the TreasuryPermission entity.
func (m *TreasuryRoleMutation) RemovedPermissionsIDs() (ids []uuid.UUID) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *TreasuryRoleMutation) PermissionsIDs() (ids []uuid.UUID) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *TreasuryRoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddUserAssignmentIDs adds the "user_assignments" edge to the UserRoleAssignment entity by ids.
func (m *TreasuryRoleMutation) AddUserAssignmentIDs(ids ...uuid.UUID) {
	if m.user_assignments == nil {
		m.user_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_assignments[ids[i]] = struct{}{}
	}
}

// ClearUserAssignments clears the "user_assignments" edge to the UserRoleAssignment entity.
func (m *TreasuryRoleMutation) ClearUserAssignments() {
	m.cleareduser_assignments = true
}

// UserAssignmentsCleared reports if the "user_assignments" edge to the UserRoleAssignment entity was cleared.
func (m *TreasuryRoleMutation) UserAssignmentsCleared() bool {
	return m.cleareduser_assignments
}

// RemoveUserAssignmentIDs removes the "user_assignments" edge to the UserRoleAssignment entity by IDs.
func (m *TreasuryRoleMutation) RemoveUserAssignmentIDs(ids ...uuid.UUID) {
	if m.removeduser_assignments == nil {
		m.removeduser_assignments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_assignments, ids[i])
		m.removeduser_assignments[ids[i]] = struct{}{}
	}
}

// RemovedUserAssignments returns the removed IDs of the "user_assignments" edge to the UserRoleAssignment entity.
func (m *TreasuryRoleMutation) RemovedUserAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_assignments {
		ids = append(ids, id)
	}
	return
}

// UserAssignmentsIDs returns the "user_assignments" edge IDs in the mutation.
func (m *TreasuryRoleMutation) UserAssignmentsIDs() (ids []uuid.UUID) {
	for id := range m.user_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetUserAssignments resets all changes to the "user_assignments" edge.
func (m *TreasuryRoleMutation) ResetUserAssignments() {
	m.user_assignments = nil
	m.cleareduser_assignments = false
	m.removeduser_assignments = nil
}

// AddRolePermissionIDs adds the "role_permissions" edge to the RolePermission entity by ids.
func (m *TreasuryRoleMutation) AddRolePermissionIDs(ids ...int) {
	if m.role_permissions == nil {
		m.role_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.role_permissions[ids[i]] = struct{}{}
	}
}

// ClearRolePermissions clears the "role_permissions" edge to the RolePermission entity.
func (m *TreasuryRoleMutation) ClearRolePermissions() {
	m.clearedrole_permissions = true
}

// RolePermissionsCleared reports if the "role_permissions" edge to the RolePermission entity was cleared.
func (m *TreasuryRoleMutation) RolePermissionsCleared() bool {
	return m.clearedrole_permissions
}

// RemoveRolePermissionIDs removes the "role_permissions" edge to the RolePermission entity by IDs.
func (m *TreasuryRoleMutation) RemoveRolePermissionIDs(ids ...int) {
	if m.removedrole_permissions == nil {
		m.removedrole_permissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.role_permissions, ids[i])
		m.removedrole_permissions[ids[i]] = struct{}{}
	}
}

// RemovedRolePermissions returns the removed IDs of the "role_permissions" edge to the RolePermission entity.
func (m *TreasuryRoleMutation) RemovedRolePermissionsIDs() (ids []int) {
	for id := range m.removedrole_permissions {
		ids = append(ids, id)
	}
	return
}

// RolePermissionsIDs returns the "role_permissions" edge IDs in the mutation.
func (m *TreasuryRoleMutation) RolePermissionsIDs() (ids []int) {
	for id := range m.role_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetRolePermissions resets all changes to the "role_permissions" edge.
func (m *TreasuryRoleMutation) ResetRolePermissions() {
	m.role_permissions = nil
	m.clearedrole_permissions = false
	m.removedrole_permissions = nil
}

// Where appends a list predicates to the TreasuryRoleMutation builder.
func (m *TreasuryRoleMutation) Where(ps ...predicate.TreasuryRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreasuryRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreasuryRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TreasuryRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreasuryRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreasuryRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TreasuryRole).
func (m *TreasuryRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreasuryRoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant_id != nil {
		fields = append(fields, treasuryrole.FieldTenantID)
	}
	if m.role_code != nil {
		fields = append(fields, treasuryrole.FieldRoleCode)
	}
	if m.name != nil {
		fields = append(fields, treasuryrole.FieldName)
	}
	if m.description != nil {
		fields = append(fields, treasuryrole.FieldDescription)
	}
	if m.is_system_role != nil {
		fields = append(fields, treasuryrole.FieldIsSystemRole)
	}
	if m.created_at != nil {
		fields = append(fields, treasuryrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, treasuryrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreasuryRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treasuryrole.FieldTenantID:
		return m.TenantID()
	case treasuryrole.FieldRoleCode:
		return m.RoleCode()
	case treasuryrole.FieldName:
		return m.Name()
	case treasuryrole.FieldDescription:
		return m.Description()
	case treasuryrole.FieldIsSystemRole:
		return m.IsSystemRole()
	case treasuryrole.FieldCreatedAt:
		return m.CreatedAt()
	case treasuryrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreasuryRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treasuryrole.FieldTenantID:
		return m.OldTenantID(ctx)
	case treasuryrole.FieldRoleCode:
		return m.OldRoleCode(ctx)
	case treasuryrole.FieldName:
		return m.OldName(ctx)
	case treasuryrole.FieldDescription:
		return m.OldDescription(ctx)
	case treasuryrole.FieldIsSystemRole:
		return m.OldIsSystemRole(ctx)
	case treasuryrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case treasuryrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TreasuryRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treasuryrole.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case treasuryrole.FieldRoleCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleCode(v)
		return nil
	case treasuryrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case treasuryrole.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case treasuryrole.FieldIsSystemRole:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSystemRole(v)
		return nil
	case treasuryrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case treasuryrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TreasuryRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreasuryRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreasuryRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreasuryRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreasuryRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treasuryrole.FieldDescription) {
		fields = append(fields, treasuryrole.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreasuryRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreasuryRoleMutation) ClearField(name string) error {
	switch name {
	case treasuryrole.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown TreasuryRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreasuryRoleMutation) ResetField(name string) error {
	switch name {
	case treasuryrole.FieldTenantID:
		m.ResetTenantID()
		return nil
	case treasuryrole.FieldRoleCode:
		m.ResetRoleCode()
		return nil
	case treasuryrole.FieldName:
		m.ResetName()
		return nil
	case treasuryrole.FieldDescription:
		m.ResetDescription()
		return nil
	case treasuryrole.FieldIsSystemRole:
		m.ResetIsSystemRole()
		return nil
	case treasuryrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case treasuryrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TreasuryRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreasuryRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.permissions != nil {
		edges = append(edges, treasuryrole.EdgePermissions)
	}
	if m.user_assignments != nil {
		edges = append(edges, treasuryrole.EdgeUserAssignments)
	}
	if m.role_permissions != nil {
		edges = append(edges, treasuryrole.EdgeRolePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreasuryRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treasuryrole.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case treasuryrole.EdgeUserAssignments:
		ids := make([]ent.Value, 0, len(m.user_assignments))
		for id := range m.user_assignments {
			ids = append(ids, id)
		}
		return ids
	case treasuryrole.EdgeRolePermissions:
		ids := make([]ent.Value, 0, len(m.role_permissions))
		for id := range m.role_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreasuryRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpermissions != nil {
		edges = append(edges, treasuryrole.EdgePermissions)
	}
	if m.removeduser_assignments != nil {
		edges = append(edges, treasuryrole.EdgeUserAssignments)
	}
	if m.removedrole_permissions != nil {
		edges = append(edges, treasuryrole.EdgeRolePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreasuryRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treasuryrole.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case treasuryrole.EdgeUserAssignments:
		ids := make([]ent.Value, 0, len(m.removeduser_assignments))
		for id := range m.removeduser_assignments {
			ids = append(ids, id)
		}
		return ids
	case treasuryrole.EdgeRolePermissions:
		ids := make([]ent.Value, 0, len(m.removedrole_permissions))
		for id := range m.removedrole_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreasuryRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpermissions {
		edges = append(edges, treasuryrole.EdgePermissions)
	}
	if m.cleareduser_assignments {
		edges = append(edges, treasuryrole.EdgeUserAssignments)
	}
	if m.clearedrole_permissions {
		edges = append(edges, treasuryrole.EdgeRolePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreasuryRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case treasuryrole.EdgePermissions:
		return m.clearedpermissions
	case treasuryrole.EdgeUserAssignments:
		return m.cleareduser_assignments
	case treasuryrole.EdgeRolePermissions:
		return m.clearedrole_permissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreasuryRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TreasuryRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreasuryRoleMutation) ResetEdge(name string) error {
	switch name {
	case treasuryrole.EdgePermissions:
		m.ResetPermissions()
		return nil
	case treasuryrole.EdgeUserAssignments:
		m.ResetUserAssignments()
		return nil
	case treasuryrole.EdgeRolePermissions:
		m.ResetRolePermissions()
		return nil
	}
	return fmt.Errorf("unknown TreasuryRole edge %s", name)
}

// TreasuryUserMutation represents an operation that mutates the TreasuryUser nodes in the graph.
type TreasuryUserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	tenant_id            *uuid.UUID
	auth_service_user_id *uuid.UUID
	email                *string
	status               *string
	sync_status          *string
	last_sync_at         *time.Time
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*TreasuryUser, error)
	predicates           []predicate.TreasuryUser
}

var _ ent.Mutation = (*TreasuryUserMutation)(nil)

// treasuryuserOption allows management of the mutation configuration using functional options.
type treasuryuserOption func(*TreasuryUserMutation)

// newTreasuryUserMutation creates new mutation for the TreasuryUser entity.
func newTreasuryUserMutation(c config, op Op, opts ...treasuryuserOption) *TreasuryUserMutation {
	m := &TreasuryUserMutation{
		config:        c,
		op:            op,
		typ:           TypeTreasuryUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreasuryUserID sets the ID field of the mutation.
func withTreasuryUserID(id uuid.UUID) treasuryuserOption {
	return func(m *TreasuryUserMutation) {
		var (
			err   error
			once  sync.Once
			value *TreasuryUser
		)
		m.oldValue = func(ctx context.Context) (*TreasuryUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreasuryUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreasuryUser sets the old TreasuryUser of the mutation.
func withTreasuryUser(node *TreasuryUser) treasuryuserOption {
	return func(m *TreasuryUserMutation) {
		m.oldValue = func(context.Context) (*TreasuryUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreasuryUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreasuryUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TreasuryUser entities.
func (m *TreasuryUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreasuryUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreasuryUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TreasuryUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TreasuryUserMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TreasuryUserMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TreasuryUser entity.
// If the TreasuryUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryUserMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TreasuryUserMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetAuthServiceUserID sets the "auth_service_user_id" field.
func (m *TreasuryUserMutation) SetAuthServiceUserID(u uuid.UUID) {
	m.auth_service_user_id = &u
}

// AuthServiceUserID returns the value of the "auth_service_user_id" field in the mutation.
func (m *TreasuryUserMutation) AuthServiceUserID() (r uuid.UUID, exists bool) {
	v := m.auth_service_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthServiceUserID returns the old "auth_service_user_id" field's value of the TreasuryUser entity.
// If the TreasuryUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryUserMutation) OldAuthServiceUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthServiceUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthServiceUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthServiceUserID: %w", err)
	}
	return oldValue.AuthServiceUserID, nil
}

// ResetAuthServiceUserID resets all changes to the "auth_service_user_id" field.
func (m *TreasuryUserMutation) ResetAuthServiceUserID() {
	m.auth_service_user_id = nil
}

// SetEmail sets the "email" field.
func (m *TreasuryUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TreasuryUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the TreasuryUser entity.
// If the TreasuryUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TreasuryUserMutation) ResetEmail() {
	m.email = nil
}

// SetStatus sets the "status" field.
func (m *TreasuryUserMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TreasuryUserMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TreasuryUser entity.
// If the TreasuryUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryUserMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TreasuryUserMutation) ResetStatus() {
	m.status = nil
}

// SetSyncStatus sets the "sync_status" field.
func (m *TreasuryUserMutation) SetSyncStatus(s string) {
	m.sync_status = &s
}

// SyncStatus returns the value of the "sync_status" field in the mutation.
func (m *TreasuryUserMutation) SyncStatus() (r string, exists bool) {
	v := m.sync_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncStatus returns the old "sync_status" field's value of the TreasuryUser entity.
// If the TreasuryUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryUserMutation) OldSyncStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncStatus: %w", err)
	}
	return oldValue.SyncStatus, nil
}

// ResetSyncStatus resets all changes to the "sync_status" field.
func (m *TreasuryUserMutation) ResetSyncStatus() {
	m.sync_status = nil
}

// SetLastSyncAt sets the "last_sync_at" field.
func (m *TreasuryUserMutation) SetLastSyncAt(t time.Time) {
	m.last_sync_at = &t
}

// LastSyncAt returns the value of the "last_sync_at" field in the mutation.
func (m *TreasuryUserMutation) LastSyncAt() (r time.Time, exists bool) {
	v := m.last_sync_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncAt returns the old "last_sync_at" field's value of the TreasuryUser entity.
// If the TreasuryUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryUserMutation) OldLastSyncAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncAt: %w", err)
	}
	return oldValue.LastSyncAt, nil
}

// ClearLastSyncAt clears the value of the "last_sync_at" field.
func (m *TreasuryUserMutation) ClearLastSyncAt() {
	m.last_sync_at = nil
	m.clearedFields[treasuryuser.FieldLastSyncAt] = struct{}{}
}

// LastSyncAtCleared returns if the "last_sync_at" field was cleared in this mutation.
func (m *TreasuryUserMutation) LastSyncAtCleared() bool {
	_, ok := m.clearedFields[treasuryuser.FieldLastSyncAt]
	return ok
}

// ResetLastSyncAt resets all changes to the "last_sync_at" field.
func (m *TreasuryUserMutation) ResetLastSyncAt() {
	m.last_sync_at = nil
	delete(m.clearedFields, treasuryuser.FieldLastSyncAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TreasuryUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TreasuryUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TreasuryUser entity.
// If the TreasuryUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TreasuryUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TreasuryUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TreasuryUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TreasuryUser entity.
// If the TreasuryUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreasuryUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TreasuryUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the TreasuryUserMutation builder.
func (m *TreasuryUserMutation) Where(ps ...predicate.TreasuryUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreasuryUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreasuryUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TreasuryUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreasuryUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreasuryUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TreasuryUser).
func (m *TreasuryUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreasuryUserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant_id != nil {
		fields = append(fields, treasuryuser.FieldTenantID)
	}
	if m.auth_service_user_id != nil {
		fields = append(fields, treasuryuser.FieldAuthServiceUserID)
	}
	if m.email != nil {
		fields = append(fields, treasuryuser.FieldEmail)
	}
	if m.status != nil {
		fields = append(fields, treasuryuser.FieldStatus)
	}
	if m.sync_status != nil {
		fields = append(fields, treasuryuser.FieldSyncStatus)
	}
	if m.last_sync_at != nil {
		fields = append(fields, treasuryuser.FieldLastSyncAt)
	}
	if m.created_at != nil {
		fields = append(fields, treasuryuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, treasuryuser.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreasuryUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treasuryuser.FieldTenantID:
		return m.TenantID()
	case treasuryuser.FieldAuthServiceUserID:
		return m.AuthServiceUserID()
	case treasuryuser.FieldEmail:
		return m.Email()
	case treasuryuser.FieldStatus:
		return m.Status()
	case treasuryuser.FieldSyncStatus:
		return m.SyncStatus()
	case treasuryuser.FieldLastSyncAt:
		return m.LastSyncAt()
	case treasuryuser.FieldCreatedAt:
		return m.CreatedAt()
	case treasuryuser.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreasuryUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treasuryuser.FieldTenantID:
		return m.OldTenantID(ctx)
	case treasuryuser.FieldAuthServiceUserID:
		return m.OldAuthServiceUserID(ctx)
	case treasuryuser.FieldEmail:
		return m.OldEmail(ctx)
	case treasuryuser.FieldStatus:
		return m.OldStatus(ctx)
	case treasuryuser.FieldSyncStatus:
		return m.OldSyncStatus(ctx)
	case treasuryuser.FieldLastSyncAt:
		return m.OldLastSyncAt(ctx)
	case treasuryuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case treasuryuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TreasuryUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treasuryuser.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case treasuryuser.FieldAuthServiceUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthServiceUserID(v)
		return nil
	case treasuryuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case treasuryuser.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case treasuryuser.FieldSyncStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncStatus(v)
		return nil
	case treasuryuser.FieldLastSyncAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncAt(v)
		return nil
	case treasuryuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case treasuryuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TreasuryUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreasuryUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreasuryUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreasuryUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreasuryUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreasuryUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treasuryuser.FieldLastSyncAt) {
		fields = append(fields, treasuryuser.FieldLastSyncAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreasuryUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreasuryUserMutation) ClearField(name string) error {
	switch name {
	case treasuryuser.FieldLastSyncAt:
		m.ClearLastSyncAt()
		return nil
	}
	return fmt.Errorf("unknown TreasuryUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreasuryUserMutation) ResetField(name string) error {
	switch name {
	case treasuryuser.FieldTenantID:
		m.ResetTenantID()
		return nil
	case treasuryuser.FieldAuthServiceUserID:
		m.ResetAuthServiceUserID()
		return nil
	case treasuryuser.FieldEmail:
		m.ResetEmail()
		return nil
	case treasuryuser.FieldStatus:
		m.ResetStatus()
		return nil
	case treasuryuser.FieldSyncStatus:
		m.ResetSyncStatus()
		return nil
	case treasuryuser.FieldLastSyncAt:
		m.ResetLastSyncAt()
		return nil
	case treasuryuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case treasuryuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TreasuryUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreasuryUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreasuryUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreasuryUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreasuryUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreasuryUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreasuryUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreasuryUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TreasuryUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreasuryUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TreasuryUser edge %s", name)
}

// UserRoleAssignmentMutation represents an operation that mutates the UserRoleAssignment nodes in the graph.
type UserRoleAssignmentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	tenant_id     *uuid.UUID
	assigned_by   *uuid.UUID
	assigned_at   *time.Time
	expires_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	role          *uuid.UUID
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*UserRoleAssignment, error)
	predicates    []predicate.UserRoleAssignment
}

var _ ent.Mutation = (*UserRoleAssignmentMutation)(nil)

// userroleassignmentOption allows management of the mutation configuration using functional options.
type userroleassignmentOption func(*UserRoleAssignmentMutation)

// newUserRoleAssignmentMutation creates new mutation for the UserRoleAssignment entity.
func newUserRoleAssignmentMutation(c config, op Op, opts ...userroleassignmentOption) *UserRoleAssignmentMutation {
	m := &UserRoleAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRoleAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleAssignmentID sets the ID field of the mutation.
func withUserRoleAssignmentID(id uuid.UUID) userroleassignmentOption {
	return func(m *UserRoleAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRoleAssignment
		)
		m.oldValue = func(ctx context.Context) (*UserRoleAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRoleAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRoleAssignment sets the old UserRoleAssignment of the mutation.
func withUserRoleAssignment(node *UserRoleAssignment) userroleassignmentOption {
	return func(m *UserRoleAssignmentMutation) {
		m.oldValue = func(context.Context) (*UserRoleAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRoleAssignment entities.
func (m *UserRoleAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRoleAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *UserRoleAssignmentMutation) SetTenantID(u uuid.UUID) {
	m.tenant_id = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserRoleAssignmentMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserRoleAssignment entity.
// If the UserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleAssignmentMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserRoleAssignmentMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetUserID sets the "user_id" field.
func (m *UserRoleAssignmentMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleAssignmentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRoleAssignment entity.
// If the UserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleAssignmentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleAssignmentMutation) ResetUserID() {
	m.user = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleAssignmentMutation) SetRoleID(u uuid.UUID) {
	m.role = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleAssignmentMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRoleAssignment entity.
// If the UserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleAssignmentMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleAssignmentMutation) ResetRoleID() {
	m.role = nil
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserRoleAssignmentMutation) SetAssignedBy(u uuid.UUID) {
	m.assigned_by = &u
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserRoleAssignmentMutation) AssignedBy() (r uuid.UUID, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserRoleAssignment entity.
// If the UserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleAssignmentMutation) OldAssignedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserRoleAssignmentMutation) ResetAssignedBy() {
	m.assigned_by = nil
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserRoleAssignmentMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserRoleAssignmentMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserRoleAssignment entity.
// If the UserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleAssignmentMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserRoleAssignmentMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserRoleAssignmentMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserRoleAssignmentMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserRoleAssignment entity.
// If the UserRoleAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleAssignmentMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *UserRoleAssignmentMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[userroleassignment.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *UserRoleAssignmentMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[userroleassignment.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserRoleAssignmentMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, userroleassignment.FieldExpiresAt)
}

// ClearUser clears the "user" edge to the TreasuryUser entity.
func (m *UserRoleAssignmentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userroleassignment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the TreasuryUser entity was cleared.
func (m *UserRoleAssignmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserRoleAssignmentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserRoleAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the TreasuryRole entity.
func (m *UserRoleAssignmentMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[userroleassignment.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the TreasuryRole entity was cleared.
func (m *UserRoleAssignmentMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserRoleAssignmentMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserRoleAssignmentMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserRoleAssignmentMutation builder.
func (m *UserRoleAssignmentMutation) Where(ps ...predicate.UserRoleAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserRoleAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserRoleAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserRoleAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserRoleAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserRoleAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserRoleAssignment).
func (m *UserRoleAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant_id != nil {
		fields = append(fields, userroleassignment.FieldTenantID)
	}
	if m.user != nil {
		fields = append(fields, userroleassignment.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, userroleassignment.FieldRoleID)
	}
	if m.assigned_by != nil {
		fields = append(fields, userroleassignment.FieldAssignedBy)
	}
	if m.assigned_at != nil {
		fields = append(fields, userroleassignment.FieldAssignedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, userroleassignment.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userroleassignment.FieldTenantID:
		return m.TenantID()
	case userroleassignment.FieldUserID:
		return m.UserID()
	case userroleassignment.FieldRoleID:
		return m.RoleID()
	case userroleassignment.FieldAssignedBy:
		return m.AssignedBy()
	case userroleassignment.FieldAssignedAt:
		return m.AssignedAt()
	case userroleassignment.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userroleassignment.FieldTenantID:
		return m.OldTenantID(ctx)
	case userroleassignment.FieldUserID:
		return m.OldUserID(ctx)
	case userroleassignment.FieldRoleID:
		return m.OldRoleID(ctx)
	case userroleassignment.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case userroleassignment.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case userroleassignment.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserRoleAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userroleassignment.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case userroleassignment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userroleassignment.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userroleassignment.FieldAssignedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case userroleassignment.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case userroleassignment.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserRoleAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRoleAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userroleassignment.FieldExpiresAt) {
		fields = append(fields, userroleassignment.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleAssignmentMutation) ClearField(name string) error {
	switch name {
	case userroleassignment.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown UserRoleAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleAssignmentMutation) ResetField(name string) error {
	switch name {
	case userroleassignment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case userroleassignment.FieldUserID:
		m.ResetUserID()
		return nil
	case userroleassignment.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userroleassignment.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case userroleassignment.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case userroleassignment.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown UserRoleAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userroleassignment.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, userroleassignment.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userroleassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userroleassignment.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userroleassignment.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, userroleassignment.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case userroleassignment.EdgeUser:
		return m.cleareduser
	case userroleassignment.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case userroleassignment.EdgeUser:
		m.ClearUser()
		return nil
	case userroleassignment.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserRoleAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case userroleassignment.EdgeUser:
		m.ResetUser()
		return nil
	case userroleassignment.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserRoleAssignment edge %s", name)
}
